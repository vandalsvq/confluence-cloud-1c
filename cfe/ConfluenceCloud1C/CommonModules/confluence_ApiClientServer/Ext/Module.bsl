
#Область future_methods

// https://github.com/atlassian-api/atlassian-python-api

//	page_exists(self, space, title)
//	get_child_title_list(self, page_id, type="page", start=None, limit=None)
//	get_child_id_list(self, page_id, type="page", start=None, limit=None)
//	get_page_id(self, space, title)
//	get_parent_content_id(self, page_id)
//	get_parent_content_title(self, page_id)
//	get_page_space(self, page_id)
//	get_pages_by_title(self, space, title, start=0, limit=200, expand=None)
//	get_page_by_title(self, space, title, start=0, limit=1, expand=None)
//	get_page_by_id(self, page_id, expand=None, status=None, version=None)
//	get_page_labels(self, page_id, prefix=None, start=None, limit=None)
//	get_page_comments(self, content_id, expand=None, parent_version=None, start=0, limit=25, location=None, depth=None)
//	get_draft_page_by_id(self, page_id, status="draft")
//	get_all_pages_by_label(self, label, start=0, limit=50)
//	get_all_pages_from_space_trash(self, space, start=0, limit=500, status="trashed", content_type="page")
//	get_all_draft_pages_from_space(self, space, start=0, limit=500, status="draft")
//	get_all_draft_pages_from_space_through_cql(self, space, start=0, limit=500, status="draft")
//	get_all_restrictions_for_content(self, content_id)
//	remove_page_from_trash(self, page_id)
//	remove_page_as_draft(self, page_id)
//	remove_content(self, content_id)
//	remove_page(self, page_id, status=None, recursive=False)
//	create_page(self, space, title, body, parent_id=None, type="page", representation="storage", editor=None)
//	move_page(self, space_key, page_id, target_id=None, target_title=None, position="append")
//	create_or_update_template(self, name, body, template_type="page", template_id=None, description=None, labels=None, space=None)
//	get_content_template(self, template_id)
//	get_blueprint_templates(self, space=None, start=0, limit=None, expand=None)
//	get_content_templates(self, space=None, start=0, limit=None, expand=None)
//	remove_template(self, template_id)
//	add_comment(self, page_id, text)
//	attach_content(self, content, name, content_type="application/binary", page_id=None, title=None, space=None, comment=None)
//	def attach_file(self, filename, name=None, content_type=None, page_id=None, title=None, space=None, comment=None)
//	delete_attachment(self, page_id, filename, version=None)
//	delete_attachment_by_id(self, attachment_id, version)
//	remove_page_attachment_keep_version(self, page_id, filename, keep_last_versions)
//	get_attachment_history(self, attachment_id, limit=200, start=0)
//	get_attachments_from_content(self, page_id, start=0, limit=50, expand=None, filename=None, media_type=None)
//	set_page_label(self, page_id, label)
//	remove_page_label(self, page_id, label)
//	history(self, page_id)
//	get_content_history(self, content_id)
//	get_content_history_by_version_number(self, content_id, version_number)
//	remove_content_history(self, page_id, version_number)
//	remove_page_history(self, page_id, version_number)
//	remove_content_history_in_cloud(self, page_id, version_id)
//	remove_page_history_keep_version(self, page_id, keep_last_versions)
//	has_unknown_attachment_error(self, page_id)
//	is_page_content_is_already_updated(self, page_id, body, title=None)
//	update_existing_page(self, page_id, title, body, type="page", representation="storage", minor_edit=False, version_comment=None)
//	update_page(self, page_id, title, body=None, parent_id=None, type="page", representation="storage", minor_edit=False, version_comment=None, always_update=False)
//	_insert_to_existing_page(self, page_id, title, insert_body, parent_id=None, type="page", representation="storage", minor_edit=False, version_comment=None, top_of_page=False)
//	append_page(self, page_id, title, append_body, parent_id=None, type="page", representation="storage", minor_edit=False)
//	prepend_page(self, page_id, title, prepend_body, parent_id=None, type="page", representation="storage", minor_edit=False)
//	update_or_create(self, parent_id, title, body, representation="storage", minor_edit=False, version_comment=None, editor=None)
//	convert_wiki_to_storage(self, wiki)
//	set_page_property(self, page_id, data)
//	update_page_property(self, page_id, data)
//	delete_page_property(self, page_id, page_property)
//	get_page_property(self, page_id, page_property_key)
//	get_page_properties(self, page_id)
//	get_page_ancestors(self, page_id)
//	clean_all_caches(self)
//	clean_package_cache(self, cache_name="com.gliffy.cache.gon")
//	get_all_groups(self, start=0, limit=1000)
//	get_group_members(self, group_name="confluence-users", start=0, limit=1000, expand=None)
//	get_all_members(self, group_name="confluence-users", expand=None)
//	get_space(self, space_key, expand="description.plain,homepage", params=None)
//	get_space_content(self, space_key, depth="all", start=0, limit=500, content_type=None, expand="body.storage")
//	get_home_page_of_space(self, space_key)
//	create_space(self, space_key, space_name)
//	delete_space(self, space_key)
//	get_space_property(self, space_key, expand=None)
//	get_user_details_by_username(self, username, expand=None)
//	get_user_details_by_userkey(self, userkey, expand=None)
//	cql(self, cql, start=0, limit=None, expand=None, include_archived_spaces=None, excerpt=None)
//	get_page_as_pdf(self, page_id)
//	get_page_as_word(self, page_id)
//	export_page(self, page_id)
//	get_descendant_page_id(self, space, parent_id, title)
//	reindex(self)
//	reindex_get_status(self)
//	health_check(self)
//	synchrony_enable(self)
//	synchrony_disable(self)
//	check_access_mode(self)
//	anonymous(self)
//	upload_plugin(self, plugin_path)
//	delete_plugin(self, plugin_key)
//	check_long_tasks_result(self, start=None, limit=None, expand=None)
//	check_long_task_result(self, task_id, expand=None)
//	get_pdf_download_url_for_confluence_cloud(self, url)
//	audit(self, start_date=None, end_date=None, start=None, limit=None, search_string=None)

#КонецОбласти 

#Область ПрограммныйИнтерфейс_Общий
 
// Возвращает структуру настроек подключения
//
// Параметры:
//	ДанныеСервера	- Строка, Структура
//		Строка		- адрес сервера для получения структуры параметров подключения
//		Структура	- см. confluence_ИнтеграцияКлиентСерверПовтИсп.ПараметрыАдресаСервера
//	Логин			- Строка - логин пользователя
//	ТокенID			- Строка - токен пользователя
//
// Возвращаемое значение:
//   Структура
//		Сервер					- Строка
//		ЗащищенноеСоединение	- Булево
//		СтрокаАвторизации		- Строка
//		АдресСервераWiki		- Строка
// 
Функция get_connection_settings(знач ДанныеСервера, знач Логин = "", знач ТокенID = "") Экспорт
	ТипДанныхСервера = ТипЗнч(ДанныеСервера);
	Если ТипДанныхСервера = Тип("Строка") Тогда
		ПараметрыСервера = confluence_ApiClientServerReuse.url_params(ДанныеСервера);
	ИначеЕсли ТипДанныхСервера = Тип("Структура") Тогда
		ПараметрыСервера = ДанныеСервера;
	Иначе 
		ВызватьИсключение НСтр("ru='Параметр ""ДанныеСервера"" передан неверно. Обратитесь к разработчику.'");
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(Логин) Тогда
		ДанныеАвторизации = СтрШаблон("%1:%2",
			Логин,
			ТокенID);
		СтрокаАвторизации = СтрокаВBase64(ДанныеАвторизации);
	Иначе 
		СтрокаАвторизации = "";
	КонецЕсли;
	
	Настройки = Новый Структура;
	Настройки.Вставить("Сервер"					, ПараметрыСервера.СерверHTTP);
	Настройки.Вставить("ЗащищенноеСоединение"	, ПараметрыСервера.ЗащищенноеСоединение);
	Настройки.Вставить("СтрокаАвторизации"		, СтрокаАвторизации);
	Настройки.Вставить("АдресСервераWiki"		, ПараметрыСервера.АдресСервераWiki);
	
	Возврат Настройки;
КонецФункции

// Выполняет проверку структуры на принадлженость к ошибке. Возвращает признак,
// что переданная структура - это описание ошибки. При необходимости выводит
// сообщение пользователю с текстом ошибки
//
// Параметры:
//	Структура			- Структура
//	СообщениеИсключение	- Булево - если значение не булево, ничего не происходит
//		Истина	- выводить сообщение
//		Ложь	- вызвать исключение
//
// Возвращаемое значение:
//   Булево
// 
Функция check_error(знач Структура, знач СообщениеИсключение = Неопределено) Экспорт 
	ТипСтруктуры = СвойствоСтруктуры(Структура, "type", "");
	
	ЭтоОшибка = (ТипСтруктуры = "error");
	Если НЕ ЭтоОшибка Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ДопТекст = СокрЛП(Структура.ДопТекст);
	Если НЕ ПустаяСтрока(ДопТекст) Тогда
		Если НЕ СтрЗаканчиваетсяНа(ДопТекст, ".") Тогда
			ДопТекст = ДопТекст + ".";
		КонецЕсли;
		ДопТекст = ДопТекст + " ";
	КонецЕсли;
	
	ТекстОшибки = СтрШаблон(НСтр("ru='%1Код ошибки: %2 (%3)'"),
		ДопТекст,
		Строка(Структура.Код),
		СокрЛП(Структура.Текст));
		
	Если СообщениеИсключение = Истина Тогда
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстОшибки);
	ИначеЕсли СообщениеИсключение = Ложь Тогда
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Возврат Истина;
КонецФункции

#КонецОбласти

#Область ПрограммныйИнтерфейс_spaces

// Возвращает все пространства. Список упорядочен в алфавитном порядке в порядке возрастания по ключу
//
// Параметры:
//	Настройки			- Структура - см. get_connection_settings
//	ПараметрыЗапроса	- Структура	- см. get_all_spaces_params
//
// Возвращаемое значение:
//   Структура - type = spacearray
// 
Функция get_all_spaces(знач Настройки, знач ПараметрыЗапроса = Неопределено) Экспорт
	СтрокаПараметры = ПараметрыЗапроса_get_all_spaces(ПараметрыЗапроса);
	СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "expand", "description.view,metadata.labels,homepage");
	
	ТекстЗапроса = "/wiki/rest/api/space?" + СтрокаПараметры;
	
	#Область ЗапросHTTP
	ЗаголовкиHTTP	= ПолучитьЗаголовки(Настройки);
	ЗапросHTTP		= Новый HTTPЗапрос(ТекстЗапроса, ЗаголовкиHTTP);
	СоединениеHTTP	= ПолучитьСоединениеHTTP(Настройки);
	#КонецОбласти 
	
	ОтветHTTP = СоединениеHTTP.Получить(ЗапросHTTP);
	Если ОтветHTTP.КодСостояния <> 200 Тогда
		Возврат Структура_error(ОтветHTTP, НСтр("ru='Получение всех пространств.'"));
	КонецЕсли;
	
	ДанныеОтвета = СоответствиеИзОтвета(ОтветHTTP);
	Возврат Структура_spacearray(ДанныеОтвета, Настройки);
КонецФункции

// Возвращает все страницы из пространства
//
// Параметры:
//	Настройки			- Структура - см. get_connection_settings
//	КлючПространства	- Строка - ключ пространства (Структура_space.Ключ)
//	ПараметрыЗапроса	- Структура - см. get_all_pages_from_space_params
//
// Возвращаемое значение:
//   Структура - type = contentarray
// 
Функция get_all_pages_from_space(знач Настройки, знач КлючПространства, знач ПараметрыЗапроса = Неопределено) Экспорт
	СтрокаПараметры = ПараметрыЗапроса_get_all_pages_from_space(ПараметрыЗапроса);
	СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "type", "page");
	СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "spaceKey", КлючПространства);
	СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "expand", ПолучитьНастройкуСодержимогоКонтента());
	
	ТекстЗапроса = "/wiki/rest/api/content?" + СтрокаПараметры;
	
	#Область ЗапросHTTP
	ЗаголовкиHTTP	= ПолучитьЗаголовки(Настройки);
	ЗапросHTTP		= Новый HTTPЗапрос(ТекстЗапроса, ЗаголовкиHTTP);
	СоединениеHTTP	= ПолучитьСоединениеHTTP(Настройки);
	#КонецОбласти 
	
	ОтветHTTP = СоединениеHTTP.Получить(ЗапросHTTP);
	Если ОтветHTTP.КодСостояния <> 200 Тогда
		Возврат Структура_error(ОтветHTTP, НСтр("ru='Получение контента раздела.'"));
	КонецЕсли;
	
	ДанныеОтвета = СоответствиеИзОтвета(ОтветHTTP);
	Возврат Структура_contentarray(ДанныеОтвета, Настройки);
КонецФункции

// Возвращает данные пространства
//
// Параметры:
//	Настройки			- Структура - см. get_connection_settings
//	КлючПространства	- Строка - ключ пространства (Структура_space.Ключ)
//
// Возвращаемое значение:
//   Структура - type = space
// 
Функция get_space(знач Настройки, знач КлючПространства) Экспорт
	СтрокаПараметры = "";
	СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "expand", "description.view,metadata.labels,homepage");
	
	ТекстЗапроса = СтрШаблон("/wiki/rest/api/space/%1?%2", КлючПространства, СтрокаПараметры);
	
	#Область ЗапросHTTP
	ЗаголовкиHTTP	= ПолучитьЗаголовки(Настройки);
	ЗапросHTTP		= Новый HTTPЗапрос(ТекстЗапроса, ЗаголовкиHTTP);
	СоединениеHTTP	= ПолучитьСоединениеHTTP(Настройки);
	#КонецОбласти 
	
	ОтветHTTP = СоединениеHTTP.Получить(ЗапросHTTP);
	Если ОтветHTTP.КодСостояния <> 200 Тогда
		Возврат Структура_error(ОтветHTTP, НСтр("ru='Получение данных пространства.'"));
	КонецЕсли;
	
	ДанныеОтвета = СоответствиеИзОтвета(ОтветHTTP);
	Возврат Структура_space(ДанныеОтвета, Настройки);
КонецФункции

// Возвращает идентификатор основной страницы пространства
//
// Параметры:
//	Настройки			- Структура - см. get_connection_settings
//	КлючПространства	- Строка - ключ пространства (Структура_space.Ключ)
//
// Возвращаемое значение:
//   Строка
// 
Функция get_pageid_from_space(знач Настройки, знач КлючПространства) Экспорт
	Результат = get_space(Настройки, КлючПространства);	
	Если check_error(Результат, Неопределено) Тогда
		Возврат "";
	КонецЕсли;
	
	Возврат Результат.ДомашняяСтраница.Идентификатор;
КонецФункции

#КонецОбласти

#Область ПрограммныйИнтерфейс_pages

// Возвращает подчиненные данные по родителю и типу
//
// Параметры:
//	Настройки			- Структура - см. get_connection_settings
//	РодительИД			- Строка - идентификатор родителя
//	ТипДанных			- ПеречислениеСсылка.confluence_ТипыДанных
//	ПараметрыЗапроса	- Структура - см. get_page_child_by_type_params
//
// Возвращаемое значение:
//   Структура - type = contentarray
// 
Функция get_page_child_by_type(знач Настройки, знач РодительИД, знач ТипДанных, знач ПараметрыЗапроса = Неопределено) Экспорт
	СтрокаПараметры = ПараметрыЗапроса_get_page_child_by_type(ПараметрыЗапроса);
	СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "expand", ПолучитьНастройкуСодержимогоКонтента());
	ТипКонтента		= ТипДанныхВСтрокуConfluence(ТипДанных);
	
	ТекстЗапроса = СтрШаблон("/wiki/rest/api/content/%1/child/%2?%3", РодительИД, ТипКонтента, СтрокаПараметры);
	
	#Область ЗапросHTTP
	ЗаголовкиHTTP	= ПолучитьЗаголовки(Настройки);
	ЗапросHTTP		= Новый HTTPЗапрос(ТекстЗапроса, ЗаголовкиHTTP);
	СоединениеHTTP	= ПолучитьСоединениеHTTP(Настройки);
	#КонецОбласти 
	
	ОтветHTTP = СоединениеHTTP.Получить(ЗапросHTTP);
	Если ОтветHTTP.КодСостояния <> 200 Тогда
		Возврат Структура_error(ОтветHTTP, НСтр("ru='Получение подчиненных страниц по типу.'"));
	КонецЕсли;
	
	ДанныеОтвета = СоответствиеИзОтвета(ОтветHTTP);
	Возврат Структура_contentarray(ДанныеОтвета, Настройки);
КонецФункции

// Возвращает все подчиненные статьи по родителю
//
// Параметры:
//	Настройки			- Структура - см. get_connection_settings
//	РодительИД			- Строка - идентификатор родителя
//
// Возвращаемое значение:
//   Структура - type = contentarray
// 
Функция get_child_pages(знач Настройки, знач РодительИД) Экспорт
	ТипСтатья = ПредопределенноеЗначение("Перечисление.confluence_ТипыДанных.Статья");
	Возврат get_page_child_by_type(Настройки, РодительИД, ТипСтатья);
КонецФункции

#КонецОбласти

#Область ПрограммныйИнтерфейс_content

// Возвращает контент страницы по ее идентификатору
// При этом структура данных содержит заполненный реквизит body_storage
//
// Параметры:
//	Настройки	- Структура - см. get_connection_settings
//	СтраницаИД	- Строка - идентификатор страницы
//
// Возвращаемое значение:
//   Структура - type = content
// 
Функция get_page_content(знач Настройки, знач СтраницаИД) Экспорт
	СтрокаПараметры = "";
	СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "expand", ПолучитьНастройкуСодержимогоКонтента() + ",body.storage");
	
	ТекстЗапроса = СтрШаблон("/wiki/rest/api/content/%1?%2", СтраницаИД, СтрокаПараметры);
	
	#Область ЗапросHTTP
	ЗаголовкиHTTP	= ПолучитьЗаголовки(Настройки);
	ЗапросHTTP		= Новый HTTPЗапрос(ТекстЗапроса, ЗаголовкиHTTP);
	СоединениеHTTP	= ПолучитьСоединениеHTTP(Настройки);
	#КонецОбласти 
	
	ОтветHTTP = СоединениеHTTP.Получить(ЗапросHTTP);
	Если ОтветHTTP.КодСостояния <> 200 Тогда
		Возврат Структура_error(ОтветHTTP, НСтр("ru='Получение контента страницы.'"));
	КонецЕсли;
	
	ДанныеОтвета = СоответствиеИзОтвета(ОтветHTTP);
	Возврат Структура_content(ДанныеОтвета, Настройки);
КонецФункции

// Выполняет конвертацию страницы в HTML код
//
// Параметры:
//	Настройки			- Структура - см. get_connection_settings
//	СтруктураContent	- Структура - type = content
//
// Возвращаемое значение:
//   Строка
// 
Функция convert_storage_to_view(знач Настройки, знач СтруктураContent) Экспорт
	СтрокаПараметры = "";
	СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "spaceKeyContext", СтруктураContent.Пространство.Ключ);
	СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "contentIdContext", СтруктураContent.Идентификатор);
	
	ТекстЗапроса = "/wiki/rest/api/contentbody/convert/styled_view?" + СтрокаПараметры;
	
	#Область СтрокаJSON
	СтруктураДанных = Новый Структура;
	СтруктураДанных.Вставить("value"			, СтруктураContent.body_storage);
	СтруктураДанных.Вставить("representation"	, "storage");
	
	СтрокаJSON = ПолучитьСтрокуJSON(СтруктураДанных);
	#КонецОбласти 
	
	#Область ЗапросHTTP
	ЗаголовкиHTTP	= ПолучитьЗаголовки(Настройки);
	ЗапросHTTP		= Новый HTTPЗапрос(ТекстЗапроса, ЗаголовкиHTTP);
	ЗапросHTTP.УстановитьТелоИзСтроки(СтрокаJSON);
	СоединениеHTTP	= ПолучитьСоединениеHTTP(Настройки);
	#КонецОбласти 
	
	ОтветHTTP = СоединениеHTTP.ОтправитьДляОбработки(ЗапросHTTP);
	Если ОтветHTTP.КодСостояния <> 200 Тогда
		Возврат Структура_error(ОтветHTTP, НСтр("ru='Конвертация контента'"));
	КонецЕсли;
	
	ДанныеОтвета = СоответствиеИзОтвета(ОтветHTTP);
	Возврат СвойствоСоответствия(ДанныеОтвета, "value", ""); //Структура_content(ДанныеОтвета, Настройки);
КонецФункции

#КонецОбласти
 
#Область ПрограммныйИнтерфейс_ПолучениеПараметров

// Возвращает структуру параметров для получения списка разделов
//
// Возвращаемое значение:
//   Структура
//		Общие		- Булево - признак получения общих или персональных пространств 
//			Истина	- общие (global)
//			Ложь	- персональные (personal)
//			Неопределено - все
//		Действующие	- Булево
//			Истина - действующие (current)
//			Ложь - архивные (archived)
//			Неопределено - все
//		Метка		- Строка - поиск пространства по метке
//		Избранное	- Булево - получать избранные или все пространства
//			Истина	- только избранные
//			Ложь	- все пространства
//		Начало		- Число - начальный номер пространства
//		Количество	- Число - количество пространств на страницу запроса
// 
Функция get_all_spaces_params(знач Начало = 0, знач Количество = 0) Экспорт
	Структура = Новый Структура;
	Структура.Вставить("Общие"			, Неопределено);
	Структура.Вставить("Действующие"	, Неопределено);
	Структура.Вставить("Метка"			, "");
	Структура.Вставить("Избранное"		, Ложь);
	Структура.Вставить("Начало"			, Начало);
	Структура.Вставить("Количество"		, Количество);
	
	Возврат Структура; 
КонецФункции

// Возвращает структуру параметров для получения списка страниц по разделу
//
// Возвращаемое значение:
//   Структура
//		Статус		- Строка - статус для отбора, по умолчанию "Любой"
//			Удален, Текущий, Любой
//		Начало		- Число - начальный номер пространства
//		Количество	- Число - количество пространств на страницу запроса
//		Сортировка	- Строка - имя поля контента и направление сортировки (ВОЗР, УБЫВ)
//			Заголовок, ДатаСоздания, ДатаИзменения, Автор
// 
Функция get_all_pages_from_space_params(знач Начало = 0, знач Количество = 0) Экспорт
	Структура = Новый Структура;
	Структура.Вставить("Статус"			, "");
	Структура.Вставить("Начало"			, Начало);
	Структура.Вставить("Количество"		, Количество);
	Структура.Вставить("Сортировка"		, "Заголовок ВОЗР");
	
	Возврат Структура;
КонецФункции

// Возвращает структуру параметров для получения списка подчиненных страниц по типу
//
// Возвращаемое значение:
//   Структура
//		Начало		- Число - начальный номер пространства
//		Количество	- Число - количество пространств на страницу запроса
// 
Функция get_page_child_by_type_params(знач Начало = 0, знач Количество = 0) Экспорт
	Возврат start_limit_params(Начало, Количество);
КонецФункции

// Возвращает параметры поиска
//
// Возвращаемое значение:
//   Структура
//		type			- Строка - searchparams
//		Начало			- Число - начальная строка выборки (нумерация начинается с 1)
//		Размер			- Число - размер выборки
//		Архив			- Булево - искать в архивных пространствах
//		РежимОтладки	- Булево - во время режима отладки выводится текст запроса для поиска
// 
Функция search_params(знач Начало = 1, знач Размер = 25, знач Архив = Ложь) Экспорт
	Структура = Новый Структура;
	Структура.Вставить("type"	, "searchparams");
	Структура.Вставить("Начало"	, Начало);
	Структура.Вставить("Размер"	, Размер);
	Структура.Вставить("Архив"	, Архив);
	
	Структура.Вставить("РежимОтладки", Ложь);

	Возврат Структура;
КонецФункции

// Возвращает структуру параметров с минимальным набором данных
//
// Возвращаемое значение:
//   Структура
//		Начало		- Число - начальный номер пространства
//		Количество	- Число - количество пространств на страницу запроса
// 
Функция start_limit_params(знач Начало = 0, знач Количество = 0)
	Структура = Новый Структура;
	Структура.Вставить("Начало"		, Начало);
	Структура.Вставить("Количество"	, Количество);
	
	Возврат Структура;
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции_ПараметрыЗапроса

Функция ПараметрыЗапроса_get_all_spaces(знач ПараметрыЗапроса)
	ПараметрыПоУмолчанию = get_all_spaces_params();
	ПроверитьПараметры(ПараметрыЗапроса, ПараметрыПоУмолчанию);
	
	СтрокаПараметры = "";
	
	Если ПараметрыЗапроса.Общие = Истина Тогда
		СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "type", "global");
	ИначеЕсли ПараметрыЗапроса.Общие = Ложь Тогда
		СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "type", "personal");
	КонецЕсли;
	
	Если ПараметрыЗапроса.Действующие = Истина Тогда
		СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "status", "current");
	ИначеЕсли ПараметрыЗапроса.Действующие = Ложь Тогда
		СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "status", "archived");
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(ПараметрыЗапроса.Метка) Тогда
		СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "label", ПараметрыЗапроса.Метка);
	КонецЕсли;
	
	Если ПараметрыЗапроса.Избранное = Истина Тогда
		СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "favourite", "true");
	КонецЕсли;
	
	Если ПараметрыЗапроса.Начало > 0 Тогда
		СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "start", ЗначениеВСтрокуConfluence(ПараметрыЗапроса.Начало));
	КонецЕсли;
	
	Если ПараметрыЗапроса.Количество > 0 Тогда
		СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "limit", ЗначениеВСтрокуConfluence(ПараметрыЗапроса.Количество));
	КонецЕсли;
	
	Возврат СтрокаПараметры;
КонецФункции

Функция ПараметрыЗапроса_get_all_pages_from_space(знач ПараметрыЗапроса)
	ПараметрыПоУмолчанию = get_all_pages_from_space_params();
	ПроверитьПараметры(ПараметрыЗапроса, ПараметрыПоУмолчанию);
	
	СтрокаПараметры = "";
	
	Если НЕ ПустаяСтрока(ПараметрыЗапроса.Статус) Тогда
		СтатусConfluence = СтатусВСтрокуConfluence(ПараметрыЗапроса.Статус);
		
		Если НЕ ПустаяСтрока(СтатусConfluence) Тогда
			СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "status", СтатусConfluence);
		КонецЕсли;
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(ПараметрыЗапроса.Сортировка) Тогда
		МассивПодстрок = СтрРазделить(ПараметрыЗапроса.Сортировка, " ");
		ПолеСортировки = ?(МассивПодстрок.Количество() > 0, СокрЛП(МассивПодстрок[0]), "");
		НапрСортировки = ?(МассивПодстрок.Количество() > 1, СокрЛП(МассивПодстрок[1]), "asc");
		
		Если НЕ ПустаяСтрока(ПолеСортировки) Тогда
			ПолеConfluence = ПолеСортировкиКонтентаВСтрокуConfluence(ПолеСортировки);
			НапрConfluence = ?(СокрЛП(НРег(НапрСортировки)) = "убыв", " desc", " asc");
			
			Если НЕ ПустаяСтрока(ПолеConfluence) Тогда
				СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "orderBy", ПолеConfluence + НапрСортировки);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Если ПараметрыЗапроса.Начало > 0 Тогда
		СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "start", ЗначениеВСтрокуConfluence(ПараметрыЗапроса.Начало));
	КонецЕсли;
	
	Если ПараметрыЗапроса.Количество > 0 Тогда
		СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "limit", ЗначениеВСтрокуConfluence(ПараметрыЗапроса.Количество));
	КонецЕсли;
	
	Возврат СтрокаПараметры;
КонецФункции

Функция ПараметрыЗапроса_get_page_child_by_type(знач ПараметрыЗапроса)
	ПараметрыПоУмолчанию = get_page_child_by_type_params();
	ПроверитьПараметры(ПараметрыЗапроса, ПараметрыПоУмолчанию);
	
	Возврат ПараметрыЗапроса_start_limit(ПараметрыЗапроса);
КонецФункции

Функция ПараметрыЗапроса_search(знач ПараметрыЗапроса)
	ПараметрыПоУмолчанию = search_params();
	ПроверитьПараметры(ПараметрыЗапроса, ПараметрыПоУмолчанию);
	
	Возврат СтрШаблон("&start=%1&limit=%2&includeArchivedSpaces=%3",
		ЗначениеВСтрокуConfluence(ПараметрыЗапроса.Начало-1),
		ЗначениеВСтрокуConfluence(ПараметрыЗапроса.Размер),
		ЗначениеВСтрокуConfluence(ПараметрыЗапроса.Архив));
КонецФункции

Функция ПараметрыЗапроса_start_limit(знач ПараметрыЗапроса)
	СтрокаПараметры = "";
	
	Если ПараметрыЗапроса.Начало > 0 Тогда
		СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "start", ЗначениеВСтрокуConfluence(ПараметрыЗапроса.Начало));
	КонецЕсли;
	
	Если ПараметрыЗапроса.Количество > 0 Тогда
		СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "limit", ЗначениеВСтрокуConfluence(ПараметрыЗапроса.Количество));
	КонецЕсли;
	
	Возврат СтрокаПараметры;
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции_СтруктурыДанных

// Возвращает структуру с данными из соответствия (ответ от Confluence)
//
// Параметры:
//	Соответствие - Соответствие
//
// Возвращаемое значение:
//	Структура: type = userdata
//		ИсходныеДанные	- Соответствие - исходные данные Confluence
//		Имя				- Строка
//		Ключ			- Строка
//		Тип				- Строка - known, unknown, anonymous, user
//		АдресEMail		- Строка
//		КраткоеИмя		- Строка
//		ПолноеИмя		- Строка
//		Аккаунт			- Структура
//			Идентификатор	- Строка
//			Тип				- Строка - atlassian, app
//
Функция Структура_userdata(знач Соответствие)
	СтруктураАккаунт = Новый Структура;
	СтруктураАккаунт.Вставить("Идентификатор"	, СвойствоСоответствия(Соответствие, "accountId", ""));
	СтруктураАккаунт.Вставить("Тип"				, СвойствоСоответствия(Соответствие, "accountType", ""));
	
	Результат = Новый Структура;
	Результат.Вставить("type"				, "userdata");
	Результат.Вставить("ИсходныеДанные"		, Соответствие);
	Результат.Вставить("Имя"				, СвойствоСоответствия(Соответствие, "username", ""));
	Результат.Вставить("Ключ"				, СвойствоСоответствия(Соответствие, "userKey", ""));
	Результат.Вставить("Тип"				, СвойствоСоответствия(Соответствие, "type", ""));
	Результат.Вставить("АдресEMail"			, СвойствоСоответствия(Соответствие, "email", ""));
	Результат.Вставить("КраткоеИмя"			, СвойствоСоответствия(Соответствие, "publicName", ""));
	Результат.Вставить("ПолноеИмя"			, СвойствоСоответствия(Соответствие, "displayName", "")); 
	Результат.Вставить("Аккаунт"			, СтруктураАккаунт);
	
	Возврат Результат;
КонецФункции

// Возвращает структуру с данными из соответствия (ответ от Confluence)
//
// Параметры:
//	Соответствие - Соответствие
//
// Возвращаемое значение:
//	Структура: type = version
//		ИсходныеДанные	- Соответствие - исходные данные Confluence
//		Пользователь	- Структура - type = userdata
//		ДатаИзменения	- Дата
//		Описание		- Строка
//		Номер			- Число
//		НеСущественное	- Булево
//
Функция Структура_version(знач Соответствие)
	ДанныеПользователь = СвойствоСоответствия(Соответствие, "by", Новый Соответствие);
	
	СтруктураПользователь = Структура_userdata(ДанныеПользователь);
	
	Результат = Новый Структура;
	Результат.Вставить("type"				, "version");
	Результат.Вставить("ИсходныеДанные"		, Соответствие);
	Результат.Вставить("Пользователь"		, СтруктураПользователь);
	Результат.Вставить("ДатаИзменения"		, ДатаИзЗначения(Соответствие, "when"));
	Результат.Вставить("Описание"			, СвойствоСоответствия(Соответствие, "message", ""));
	Результат.Вставить("Номер"				, ЧислоИзЗначения(Соответствие, "number"));
	Результат.Вставить("НеСущественное"		, БулевоИзЗначения(Соответствие, "minorEdit"));
	
	Возврат Результат;
КонецФункции

// Возвращает структуру с данными из соответствия (ответ от Confluence)
//
// Параметры:
//	Соответствие - Соответствие
//
// Возвращаемое значение:
//	Структура: type = space
//		ИсходныеДанные	- Соответствие - исходные данные Confluence
//		Идентификатор		- Строка
//		Ключ				- Строка
//		Наименование		- Строка
//		Описание			- Строка
//		ДомашняяСтраница	- Структура - type = homepage
//		Общее				- Булево
//		Действующее			- Булево
//		Метки				- Массив
//			Префикс			- Строка
//			Представление	- Строка
//			Идентификатор	- Строка
//			Метка			- Строка
//
Функция Структура_space(знач Соответствие, знач Настройки)
	ТипПространства			= СвойствоСоответствия(Соответствие, "type", "");
	СтатусПространства		= СвойствоСоответствия(Соответствие, "status", "");
	ОписаниеПространства	= СвойствоСоответствия(Соответствие, "description/view/value", "");
	МеткиПространства		= СвойствоСоответствия(Соответствие, "metadata/labels/results", Новый Массив);
	ДомашняяСтраница		= СвойствоСоответствия(Соответствие, "homepage", Новый Соответствие);
	
	МассивМетки = Новый Массив;
	Для Каждого СоответствиеМетки Из МеткиПространства Цикл
		СтруктураМетки = Новый Структура;
		СтруктураМетки.Вставить("Префикс"		, СвойствоСоответствия(СоответствиеМетки, "prefix", ""));
		СтруктураМетки.Вставить("Представление"	, СвойствоСоответствия(СоответствиеМетки, "name", ""));
		СтруктураМетки.Вставить("Идентификатор"	, СвойствоСоответствия(СоответствиеМетки, "id", ""));
		СтруктураМетки.Вставить("Метка"			, СвойствоСоответствия(СоответствиеМетки, "label", ""));
		
		МассивМетки.Добавить(СтруктураМетки);
	КонецЦикла;
	
	Результат = Новый Структура;
	Результат.Вставить("type"				, "space");
	Результат.Вставить("ИсходныеДанные"		, Соответствие);
	Результат.Вставить("Идентификатор"		, СвойствоСоответствия(Соответствие, "id", ""));
	Результат.Вставить("Ключ"				, СвойствоСоответствия(Соответствие, "key", ""));
	Результат.Вставить("Наименование"		, СвойствоСоответствия(Соответствие, "name", ""));
	Результат.Вставить("Описание"			, ЗаменитьСпецСимволыHTML(ОписаниеПространства));
	Результат.Вставить("ДомашняяСтраница"	, Структура_homepage(ДомашняяСтраница, Настройки));
	Результат.Вставить("Общее"				, (ТипПространства = "global"));
	Результат.Вставить("Действующее"		, (СтатусПространства = "current"));
	Результат.Вставить("Метки"				, МассивМетки);
	
	Возврат Результат;
КонецФункции

// Возвращает структуру с данными из соответствия (ответ от Confluence)
//
// Параметры:
//	Соответствие - Соответствие
//
// Возвращаемое значение:
//	Структура: type = spacearray
//		ИсходныеДанные	- Соответствие - исходные данные Confluence
//		Значения		- Массив
//			Элемент массива Структура: type = space
//		Начало			- Число
//		Ограничение		- Число
//		РазмерВыборки	- Число
//
Функция Структура_spacearray(знач Соответствие, знач Настройки)
	ДанныеРезультат = СвойствоСоответствия(Соответствие, "results", Новый Массив);
	
	МассивРезультат = Новый Массив;
	Для Каждого СоответствиеПространство Из ДанныеРезультат Цикл
		СтруктураПространство = Структура_space(СоответствиеПространство, Настройки);
		МассивРезультат.Добавить(СтруктураПространство);
	КонецЦикла;
	
	Результат = Новый Структура;
	Результат.Вставить("ИсходныеДанные"		, Соответствие);
	Результат.Вставить("type"				, "spacearray");
	Результат.Вставить("Значения"			, МассивРезультат);
	Результат.Вставить("Начало"				, ЧислоИзЗначения(Соответствие, "start"));
	Результат.Вставить("Ограничение"		, ЧислоИзЗначения(Соответствие, "limit"));
	Результат.Вставить("РазмерВыборки"		, ЧислоИзЗначения(Соответствие, "size"));
	
	Возврат Результат;
КонецФункции

// Возвращает структуру с данными из соответствия (ответ от Confluence)
//
// Параметры:
//	Соответствие	- Соответствие
//	Настройки		- Структура - см. ИнтеграцияConfluenceВызовСервера.НастройкиПодключения
//
// Возвращаемое значение:
//	Структура: type = homepage
//		ИсходныеДанные	- Соответствие - исходные данные Confluence
//		Идентификатор	- Строка
//		ТипДанных		- ПеречислениеСсылка.confluence_ТипыДанных
//		Заголовок		- Строка
//		Статус			- Строка - статус контента
//		Ссылки			- Структура - type = links
//
Функция Структура_homepage(знач Соответствие, знач Настройки)
	ДанныеСсылки = СвойствоСоответствия(Соответствие, "_links", Новый Соответствие);
	
	Результат = Новый Структура;
	Результат.Вставить("ИсходныеДанные"		, Соответствие);
	Результат.Вставить("type"				, "content");
	Результат.Вставить("Идентификатор"		, СвойствоСоответствия(Соответствие, "id", ""));
	Результат.Вставить("ТипДанных"			, ТипДанныхИзСтрокиConfluence(Соответствие, "type"));
	Результат.Вставить("Статус"				, СтатусИзСтрокиConfluence(Соответствие, "status"));
	Результат.Вставить("Заголовок"			, СвойствоСоответствия(Соответствие, "title", ""));
	Результат.Вставить("Ссылки"				, Структура_links(ДанныеСсылки));
	
	Возврат Результат;
КонецФункции

// Возвращает структуру с данными из соответствия (ответ от Confluence)
//
// Параметры:
//	Соответствие	- Соответствие
//	Настройки		- Структура - см. ИнтеграцияConfluenceВызовСервера.НастройкиПодключения
//
// Возвращаемое значение:
//	Структура: type = content
//		ИсходныеДанные	- Соответствие - исходные данные Confluence
//		Идентификатор	- Строка
//		ТипДанных		- ПеречислениеСсылка.confluence_ТипыДанных
//		Заголовок		- Строка
//		Статус			- Строка - статус контента
//		Пространство	- Структура - type = space
//		Версия			- Структура - type = version
//		Ссылки			- Структура - type = links
//
Функция Структура_content(знач Соответствие, знач Настройки)
	ДанныеПространство	= СвойствоСоответствия(Соответствие, "space", Новый Соответствие);
	ДанныеВерсия		= СвойствоСоответствия(Соответствие, "version", Новый Соответствие);
	ДанныеСсылки		= СвойствоСоответствия(Соответствие, "_links", Новый Соответствие);
	
	ЕстьПодчиненные = БулевоИзЗначения(Соответствие, "childTypes/page/value");
	
	Результат = Новый Структура;
	Результат.Вставить("ИсходныеДанные"		, Соответствие);
	Результат.Вставить("type"				, "content");
	Результат.Вставить("Идентификатор"		, СвойствоСоответствия(Соответствие, "id", ""));
	Результат.Вставить("ТипДанных"			, ТипДанныхИзСтрокиConfluence(Соответствие, "type"));
	Результат.Вставить("Статус"				, СтатусИзСтрокиConfluence(Соответствие, "status"));
	Результат.Вставить("Заголовок"			, СвойствоСоответствия(Соответствие, "title", ""));
	Результат.Вставить("Пространство"		, Структура_space(ДанныеПространство, Настройки));
	Результат.Вставить("Версия"				, Структура_version(ДанныеВерсия));
	Результат.Вставить("Ссылки"				, Структура_links(ДанныеСсылки));
	Результат.Вставить("ЕстьПодчиненные"	, ЕстьПодчиненные);
	Результат.Вставить("body_storage"		, СвойствоСоответствия(Соответствие, "body/storage/value", ""));
	
	Возврат Результат;
КонецФункции

// Возвращает структуру с данными из соответствия (ответ от Confluence)
//
// Параметры:
//	Соответствие - Соответствие
//
// Возвращаемое значение:
//	Структура: type = contentarray
//		ИсходныеДанные	- Соответствие - исходные данные Confluence
//		Значения		- Массив
//			Элемент массива Структура: type = content
//		Начало			- Число
//		Ограничение		- Число
//		РазмерВыборки	- Число
//
Функция Структура_contentarray(знач Соответствие, знач Настройки)
	ДанныеРезультат = СвойствоСоответствия(Соответствие, "results", Новый Массив);
	
	МассивРезультат = Новый Массив;
	Для Каждого СоответствиеКонтент Из ДанныеРезультат Цикл
		СтруктураКонтент = Структура_content(СоответствиеКонтент, Настройки);
		МассивРезультат.Добавить(СтруктураКонтент);
	КонецЦикла;
	
	Результат = Новый Структура;
	Результат.Вставить("type"				, "contentarray");
	Результат.Вставить("ИсходныеДанные"		, Соответствие);
	Результат.Вставить("Значения"			, МассивРезультат);
	Результат.Вставить("Начало"				, ЧислоИзЗначения(Соответствие, "start"));
	Результат.Вставить("Ограничение"		, ЧислоИзЗначения(Соответствие, "limit"));
	Результат.Вставить("РазмерВыборки"		, ЧислоИзЗначения(Соответствие, "size"));
	
	Возврат Результат;
КонецФункции

// Возвращает структуру с данными из соответствия (ответ от Confluence)
//
// Параметры:
//	Соответствие - Соответствие
//
// Возвращаемое значение:
//	Структура: type = contentarray
//		ИсходныеДанные	- Соответствие - исходные данные Confluence
//		Страницы		- Структура - type = contentarray
//		Вложения		- Неопределено - не реализовано
//		Комментарии		- Неопределено - не реализовано
//
Функция Структура_contentchildren(знач Соответствие, знач Настройки)
	ДанныеСтраниц		= СвойствоСоответствия(Соответствие, "page", Новый Массив);
	//ДанныеВложений		= СвойствоСоответствия(Соответствие, "attachment", Новый Массив);
	//ДанныеКомментариев	= СвойствоСоответствия(Соответствие, "comment", Новый Массив);
	
	Результат = Новый Структура;
	Результат.Вставить("type"				, "contentchildren");
	Результат.Вставить("ИсходныеДанные"		, Соответствие);
	Результат.Вставить("Страницы"			, Структура_contentarray(ДанныеСтраниц, Настройки));
	Результат.Вставить("Вложения"			, Неопределено); //Структура_contentarray(ДанныеВложений));
	Результат.Вставить("Комментарии"		, Неопределено); //Структура_contentarray(ДанныеКомментариев));
	
	Возврат Результат;
КонецФункции

// Возвращает структуру с данными из соответствия (ответ от Confluence)
//
// Параметры:
//	Соответствие	- Соответствие
//	Настройки		- Структура - см. ИнтеграцияConfluenceВызовСервера.НастройкиПодключения
//
// Возвращаемое значение:
//	Структура: type = searchresult
//		ИсходныеДанные	- Соответствие - исходные данные Confluence
//		Значения		- Массив - type = space
//			Контент			- Структура - type = content
//				Только свойства: Идентификатор, ТипДанных, Статус, Заголовок, Ссылки
//			Пространство	- Структура
//				Заголовок	- Строка
//				Ссылка		- Строка
//			Заголовок		- ФорматированнаяСтрока, Строка
//			Описание		- ФорматированнаяСтрока, Строка
//			Ссылка			- Строка
//			Навигация		- Массив - элемент Структура type = breadcrumb
//			ТипДанных		- ПеречислениеСсылка.confluence_ТипыДанных
//			Обновлено		- Дата - дата (с временем) обновления
//		Начало			- Число - номер строки выборки (нумерация начинается с 0)
//		Ограничение		- Число - количество строк запроса (ПараметрыПоиска.Размер)
//		РазмерВыборки	- Число - количество строк в выборке
//		ВсегоКоличество	- Число - всего найденных строк
//		СтрокаЗапроса	- Строка - строка запроса для повторного выполнения
//		ВремяПоиска		- Число - время выполнения запроса
//
Функция Структура_searchresult(знач Соответствие, знач Настройки)
	ДанныеРезультат = СвойствоСоответствия(Соответствие, "results", Новый Массив);
	ДанныеСсылки	= СвойствоСоответствия(Соответствие, "_links", Новый Соответствие);
	
	МассивРезультат = Новый Массив;
	Для Каждого СоответствиеРезультат Из ДанныеРезультат Цикл
		ДанныеКонтента		= СвойствоСоответствия(СоответствиеРезультат, "content", Новый Соответствие);
		ДанныеПространства	= СвойствоСоответствия(СоответствиеРезультат, "resultGlobalContainer", Новый Соответствие);
		ДанныеНавигация		= СвойствоСоответствия(СоответствиеРезультат, "breadcrumbs", Новый Массив);
		
		СтруктураПространство = Новый Структура;
		СтруктураПространство.Вставить("Заголовок"	, СвойствоСоответствия(ДанныеПространства, "title", ""));
		СтруктураПространство.Вставить("Ссылка"		, АдресСсылкиИзЗначения(ДанныеПространства, "displayUrl", Настройки.АдресСервераWiki));
		
		ЗначениеЗаголовок	= СвойствоСоответствия(СоответствиеРезультат, "title", "");
		ЗначениеОписание	= СвойствоСоответствия(СоответствиеРезультат, "excerpt", "");
		МассивНавигация		= Массив_breadcrumbs(ДанныеНавигация);
		
		СтруктураКонтент = Структура_content(ДанныеКонтента, Настройки);
		СтруктураКонтент.Ссылки.Основа = СвойствоСоответствия(ДанныеСсылки, "base", "");
		
		СтруктураЗначение = Новый Структура;
		СтруктураЗначение.Вставить("Контент"		, СтруктураКонтент);
		СтруктураЗначение.Вставить("Пространство"	, СтруктураПространство);
		СтруктураЗначение.Вставить("Заголовок"		, ФорматироватьСтроку(ЗначениеЗаголовок));
		СтруктураЗначение.Вставить("Описание"		, ФорматироватьСтроку(ЗначениеОписание));
		СтруктураЗначение.Вставить("Ссылка"			, АдресСсылкиИзЗначения(СоответствиеРезультат, "url", Настройки.АдресСервераWiki));
		СтруктураЗначение.Вставить("Навигация"		, МассивНавигация); 
		СтруктураЗначение.Вставить("ТипДанных"		, ТипДанныхИзСтрокиConfluence(СоответствиеРезультат, "entityType"));
		СтруктураЗначение.Вставить("Обновлено"		, ДатаИзЗначения(СоответствиеРезультат, "lastModified"));
		
		МассивРезультат.Добавить(СтруктураЗначение);
	КонецЦикла;
	
	Результат = Новый Структура;
	Результат.Вставить("type"				, "searchresult");
	Результат.Вставить("ИсходныеДанные"		, Соответствие);
	Результат.Вставить("Значения"			, МассивРезультат);
	Результат.Вставить("Начало"				, ЧислоИзЗначения(Соответствие, "start"));
	Результат.Вставить("Ограничение"		, ЧислоИзЗначения(Соответствие, "limit"));
	Результат.Вставить("РазмерВыборки"		, ЧислоИзЗначения(Соответствие, "size"));
	Результат.Вставить("ВсегоКоличество"	, ЧислоИзЗначения(Соответствие, "totalSize"));
	Результат.Вставить("СтрокаЗапроса"		, СвойствоСоответствия(Соответствие, "cqlQuery", ""));
	Результат.Вставить("ВремяПоиска"		, ЧислоИзЗначения(Соответствие, "searchDuration"));
	
	Возврат Результат;
КонецФункции

// Возвращает структуру с данными из соответствия (ответ от Confluence)
//
// Параметры:
//	Соответствие - Соответствие
//
// Возвращаемое значение:
//	Структура: type = versions
//		ИсходныеДанные	- Соответствие - исходные данные Confluence
//		Значения		- Массив - type = version
//		Начало			- Число - номер строки выборки
//		Ограничение		- Число - количество строк запроса
//		РазмерВыборки	- Число - количество строк в выборке
//
Функция Структура_versions(знач Соответствие)
	ДанныеРезультат = СвойствоСоответствия(Соответствие, "results", Новый Массив);
	
	МассивРезультат = Новый Массив;
	Для Каждого СоответствиеРезультат Из ДанныеРезультат Цикл
		СтруктураВерсия = Структура_version(СоответствиеРезультат);
		МассивРезультат.Добавить(СтруктураВерсия);
	КонецЦикла;
	
	Результат = Новый Структура;
	Результат.Вставить("type"				, "versions");
	Результат.Вставить("ИсходныеДанные"		, Соответствие);
	Результат.Вставить("Значения"			, МассивРезультат);
	Результат.Вставить("Начало"				, ЧислоИзЗначения(Соответствие, "start"));
	Результат.Вставить("Ограничение"		, ЧислоИзЗначения(Соответствие, "limit"));
	Результат.Вставить("РазмерВыборки"		, ЧислоИзЗначения(Соответствие, "size"));
	
	Возврат Результат;
КонецФункции

// Возвращает структуру с данными из соответствия (ответ от Confluence)
//
// Параметры:
//	Соответствие - Соответствие
//
// Возвращаемое значение:
//	Структура: type = links
//		ИсходныеДанные	- Соответствие - исходные данные Confluence
//		Редактирование	- Строка - ссылка для редактирования статьи (без учета основного адреса)
//		Просмотр		- Строка - ссылка для просмотра статьи (без учета основного адреса)
//		Сокращенная		- Строка - краткая ссылка для просмотра статьи (без учета основного адреса)
//		Основа			- Строка - основной адрес расположения базы знаний
//
Функция Структура_links(знач Соответствие)
	Результат = Новый Структура;
	Результат.Вставить("type"				, "links");
	Результат.Вставить("ИсходныеДанные"		, Соответствие);
	Результат.Вставить("Редактирование"		, СвойствоСоответствия(Соответствие, "editui", ""));
	Результат.Вставить("Просмотр"			, СвойствоСоответствия(Соответствие, "webui", ""));
	Результат.Вставить("Сокращенная"		, СвойствоСоответствия(Соответствие, "tinyui", ""));
	Результат.Вставить("Основа"				, СвойствоСоответствия(Соответствие, "base", ""));
	
	Возврат Результат;
КонецФункции

// Возвращает структуру с данным ошибки
//
// Параметры:
//	ОтветHTTP	- HTTPОтвет
//	ДопТекст	- Строка
//
// Возвращаемое значение:
//	Структура: type = error
//		Код			- Число
//		Текст		- Строка
//		ДопТекст	- Строка
// 
Функция Структура_error(знач ОтветHTTP, знач ДопТекст = "")
	ТекстОшибки	= ОтветHTTP.ПолучитьТелоКакСтроку(КодировкаТекста.UTF8);
	КодОшибки	= ОтветHTTP.КодСостояния;
	
	Возврат Новый Структура("type, Код, Текст, ДопТекст",
	    "error",
		КодОшибки,
		ТекстОшибки,
		ДопТекст);
КонецФункции

// Возвращает структуру со статусом "Выполнено"
//
// Параметры:
//	ОтветHTTP	- HTTPОтвет
//	ДопТекст	- Строка
//
// Возвращаемое значение:
//	Структура: type = done
//		Код			- Число
//		ДопТекст	- Строка
// 
Функция Структура_done(знач ОтветHTTP, знач ДопТекст = "")
	КодВыполнения = ОтветHTTP.КодСостояния;
	
	Возврат Новый Структура("type, Код, ДопТекст",
	    "done",
		КодВыполнения,
		ДопТекст);
КонецФункции

// Возвращает массив с данными из соответствия (ответ от Confluence)
//
// Параметры:
//	Соответствие - Соответствие
//
// Возвращаемое значение:
//	Массив: Структура: 
//		type		= breadcrumb
//		Заголовок	- Строка
//		Ссылка		- Строка
//		Разделитель	- Строка
//
Функция Массив_breadcrumbs(знач Массив)
	МассивНавигация = Новый Массив;
	
	Для Каждого Соответствие Из Массив Цикл
		СтруктураНавигация = Новый Структура;
		СтруктураНавигация.Вставить("type"			, "breadcrumb");
		СтруктураНавигация.Вставить("Заголовок"		, СвойствоСоответствия(Соответствие, "label", ""));
		СтруктураНавигация.Вставить("Ссылка"		, СвойствоСоответствия(Соответствие, "url", ""));
		СтруктураНавигация.Вставить("Разделитель"	, СвойствоСоответствия(Соответствие, "separator", ""));
		
		МассивНавигация.Добавить(СтруктураНавигация);
	КонецЦикла;
	
	Возврат МассивНавигация;
КонецФункции

#КонецОбласти 

#Область СлужебныеПроцедурыИФункции_ОбщегоНазначения

Процедура ПроверитьПараметры(СтруктураПараметры, знач ПараметрыПоУмолчанию)
	Если НЕ ТипЗнч(СтруктураПараметры) = Тип("Структура") Тогда
		СтруктураПараметры = Новый Структура;
	КонецЕсли;
	
	Для Каждого КлючИЗначение Из ПараметрыПоУмолчанию Цикл
		ЗначениеПараметра = СвойствоСтруктуры(СтруктураПараметры, КлючИЗначение.Ключ, КлючИЗначение.Значение);
		СтруктураПараметры.Вставить(КлючИЗначение.Ключ, ЗначениеПараметра);
	КонецЦикла;
КонецПроцедуры

Функция ПолучитьНастройкуСодержимогоКонтента()
	Возврат "childTypes.page,description.view,version,ancestors,space";
КонецФункции

Функция ПолучитьСтрокуJSON(знач ОбъектДанных)
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписьJSON.ПроверятьСтруктуру = Ложь;
	ЗаписатьJSON(ЗаписьJSON, ОбъектДанных);
	Возврат ЗаписьJSON.Закрыть();	
КонецФункции

Функция ПолучитьЗаголовки(знач Настройки)
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("Content-Type", "application/json");
	
	Если НЕ ПустаяСтрока(Настройки.СтрокаАвторизации) Тогда 
		Заголовки.Вставить("Authorization", "Basic " + Настройки.СтрокаАвторизации);
	КонецЕсли;
	
	Возврат Заголовки;
КонецФункции

Функция ПолучитьСоединениеHTTP(знач Настройки)
	ЗащищенноеСоединение = ?(Настройки.ЗащищенноеСоединение, Новый ЗащищенноеСоединениеOpenSSL, Неопределено);
	Возврат Новый HTTPСоединение(Настройки.Сервер,,,,,, ЗащищенноеСоединение);
КонецФункции

Функция СоответствиеИзОтвета(знач ОтветHTTP)
	ТелоЗапроса = ОтветHTTP.ПолучитьТелоКакСтроку(КодировкаТекста.UTF8);
	
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(ТелоЗапроса);
	ТекстJSON = ПрочитатьJSON(ЧтениеJSON, Истина);
	ЧтениеJSON = Неопределено;
	
	Возврат ТекстJSON;
КонецФункции

Функция ДополнитьПараметрыЗапроса(знач ПараметрыЗапроса, знач Поле, знач Значение)
	Возврат СтрШаблон("%1%2%3=%4",
		ПараметрыЗапроса,
		?(ПустаяСтрока(ПараметрыЗапроса), "", "&"),
		Поле,
		Значение);
КонецФункции

// Возвращает значение свойства структуры.
//
// Параметры:
//   Структура - Структура
//             - ФиксированнаяСтруктура - объект, из которого необходимо прочитать значение ключа.
//   Ключ - Строка - имя свойства структуры, для которого необходимо прочитать значение.
//   ЗначениеПоУмолчанию - Произвольный - возвращается когда в структуре нет значения по указанному
//                                        ключу.
//       Для скорости рекомендуется передавать только быстро вычисляемые значения (например примитивные типы),
//       а инициализацию более тяжелых значений выполнять после проверки полученного значения (только если это
//       требуется).
//
// Возвращаемое значение:
//   Произвольный - значение свойства структуры. ЗначениеПоУмолчанию если в структуре нет указанного свойства.
//
Функция СвойствоСтруктуры(Структура, Ключ, ЗначениеПоУмолчанию = Неопределено)
	
	Если Структура = Неопределено Тогда
		Возврат ЗначениеПоУмолчанию;
	КонецЕсли;
	
	Результат = ЗначениеПоУмолчанию;
	Если Структура.Свойство(Ключ, Результат) Тогда
		Возврат Результат;
	Иначе
		Возврат ЗначениеПоУмолчанию;
	КонецЕсли;
	
КонецФункции

// Вычисляет значение из соответствия по полному пути. Актуально для получения значения
// по длинной цепочки вложенных соответствий (например из результата чтения JSON в соответствие).
//
// Например: если соответствие имеет структуру Ключ - строка, Значение - соответствие/значение
// Необходимо получить значение свойства Ключ1 > Ключ2 > Ключ3, предполагая что значением каждого
// ключа (кроме последнего) будет Соответствие. При этом если на любом этапе будет получено значение
// не типа "Соответствие" функция вернет значение параметра ПоУмолчанию. Аналогично, если на
// последнем ключе будет получено значение Неопределено
//
// Параметры:
//	Соответствие 	- Соответствие
//		Ключ - Строка - 
//		Значение - Соответствие, Произвольный
//	ПутьКСвойству 	- Строка - в качестве разделителя используется символ "/"
//	ПоУмолчанию		- Произвольный - значение возвращаемое по умолчанию, если целевое значение не получено
//
// Возвращаемое значение:
//   Произвольный
// 
Функция СвойствоСоответствия(знач Соответствие, знач ПутьКСвойству, знач ПоУмолчанию = Неопределено, знач КакЧисло = Ложь)
	МассивИмен = СтрРазделить(ПутьКСвойству, "/", Ложь);
	Для Индекс = 0 По МассивИмен.ВГраница() Цикл
		ИмяСвойства = СокрЛП(МассивИмен[Индекс]);
		
		Если Индекс = 0 Тогда
			ЗначениеСоответствия = Соответствие.Получить(ИмяСвойства);
		Иначе 
			ЗначениеСоответствия = ЗначениеСоответствия.Получить(ИмяСвойства);
		КонецЕсли;
		
		Если Индекс <> МассивИмен.ВГраница() Тогда
			ЗначениеСоответствия = ?(НЕ ТипЗнч(ЗначениеСоответствия) = Тип("Соответствие"),
				Новый Соответствие,
				ЗначениеСоответствия);
		КонецЕсли;
	КонецЦикла;
	
	Если ЗначениеСоответствия = Неопределено Тогда
		Возврат ПоУмолчанию;
	ИначеЕсли КакЧисло = Истина Тогда
		ЗначениеТип = ТипЗнч(ЗначениеСоответствия);
		Если ЗначениеТип = Тип("Число") Тогда
			Возврат ЗначениеСоответствия;
		ИначеЕсли ЗначениеТип = Тип("Строка") Тогда
			Возврат СтроковыеФункцииКлиентСервер.СтрокаВЧисло(ЗначениеСоответствия);
		Иначе 
			Возврат 0;
		КонецЕсли;
	Иначе 
		Возврат ЗначениеСоответствия;
	КонецЕсли;
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции_КонвертацияДанных

Функция ЗаменитьСпецСимволыHTML(знач ЗначениеСтроки)
	МассивЗамен = Новый Соответствие;
	МассивЗамен.Вставить("&amp;", "&");
	МассивЗамен.Вставить("&lt;", "<");
	МассивЗамен.Вставить("&gt;", ">");
	МассивЗамен.Вставить("&quot;", """");
	МассивЗамен.Вставить("&#39;", "'");
	
	СтрИсходник = ЗначениеСтроки;
	Для Каждого КлючИЗначение Из МассивЗамен Цикл
		СтрИсходник = СтрЗаменить(СтрИсходник, КлючИЗначение.Ключ, КлючИЗначение.Значение);
	КонецЦикла;
	
	Возврат СтрИсходник;
КонецФункции

Функция ФорматироватьСтроку(знач ЗначениеСтроки)
	ЗначениеСтроки = ЗаменитьСпецСимволыHTML(ЗначениеСтроки);
	Если СтрНайти(ЗначениеСтроки, "@@@hl@@@") = 0 Тогда
		Возврат ЗначениеСтроки;
	КонецЕсли;
	
	МассивПодстрок = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ЗначениеСтроки, "@@@hl@@@", Истина, Ложь);
	
	МассивПредставление = Новый Массив;
	Для Каждого Подстрока Из МассивПодстрок Цикл
		СтрОкончание	= СтрНайти(Подстрока, "@@@endhl@@@");
		НачалоСтроки	= Лев(Подстрока, СтрОкончание-1);
		ОстатокСтроки	= СтрЗаменить(Сред(Подстрока, СтрОкончание), "@@@endhl@@@", "");
		
		Если СтрОкончание > 0 Тогда
			МассивПредставление.Добавить(Новый ФорматированнаяСтрока(НачалоСтроки, Новый Шрифт(,, Истина)));
		Иначе
			МассивПредставление.Добавить(НачалоСтроки);
		КонецЕсли;
		
		МассивПредставление.Добавить(ОстатокСтроки);
	КонецЦикла;
	
	Возврат Новый ФорматированнаяСтрока(МассивПредставление);
КонецФункции

Функция ДатаИзЗначения(знач Соответствие, знач ПутьКлюча)
	ЗначениеСвойства = СвойствоСоответствия(Соответствие, ПутьКлюча, Неопределено);
	Если ЗначениеСвойства = Неопределено Тогда
		Возврат Дата(1, 1, 1);
	КонецЕсли;
	
	ТипСвойства = ТипЗнч(ЗначениеСвойства);
	Если ТипСвойства = Тип("Дата") Тогда
		Возврат ЗначениеСвойства;
	КонецЕсли;
	
	// "yyyy/MM/dd HH:mm" "yyyy-MM-dd HH:mm" "yyyy/MM/dd" "yyyy-MM-dd"
	ЗначГод		= СтрокаВЧисло(Сред(ЗначениеСвойства, 1, 4));
	ЗначМесяц	= СтрокаВЧисло(Сред(ЗначениеСвойства, 6, 2));
	ЗначДата		= СтрокаВЧисло(Сред(ЗначениеСвойства, 9, 2));
	ЗначЧас		= СтрокаВЧисло(Сред(ЗначениеСвойства, 12, 2));
	ЗначМин		= СтрокаВЧисло(Сред(ЗначениеСвойства, 15, 2));
	
	Возврат Дата(ЗначГод, ЗначМесяц, ЗначДата, ЗначЧас, ЗначМин, 0);
КонецФункции

Функция ЧислоИзЗначения(знач Соответствие, знач ПутьКлюча)
	ЗначениеСвойства = СвойствоСоответствия(Соответствие, ПутьКлюча, Неопределено);
	Если ЗначениеСвойства = Неопределено Тогда
		Возврат 0;
	КонецЕсли;
	
	ТипСвойства = ТипЗнч(ЗначениеСвойства);
	Если ТипСвойства = Тип("Число") Тогда
		Возврат ЗначениеСвойства;
	КонецЕсли;
	
	Возврат СтрокаВЧисло(ЗначениеСвойства);
КонецФункции

Функция БулевоИзЗначения(знач Соответствие, знач ПутьКлюча)
	ЗначениеСвойства = СвойствоСоответствия(Соответствие, ПутьКлюча, Неопределено);
	Если ЗначениеСвойства = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ТипСвойства = ТипЗнч(ЗначениеСвойства);
	Если ТипСвойства = Тип("Булево") Тогда
		Возврат ЗначениеСвойства;
	КонецЕсли;
	
	Возврат ?(ЗначениеСвойства = "true", Истина, Ложь);
КонецФункции

Функция АдресСсылкиИзЗначения(знач Соответствие, знач ПутьКлюча, знач ПутьКСерверу)
	ЗначениеСвойства = СвойствоСоответствия(Соответствие, ПутьКлюча, Неопределено);
	Если ЗначениеСвойства = Неопределено Тогда
		Возврат "";
	КонецЕсли;
	
	БезРазделителя = (СтрЗаканчиваетсяНа(ПутьКСерверу, "/") ИЛИ СтрНачинаетсяС(ЗначениеСвойства, "/"));
	
	Возврат ПутьКСерверу + ?(БезРазделителя, "", "/") + ЗначениеСвойства;
КонецФункции

Функция ЗначениеВСтрокуConfluence(знач ЗначениеСравнения)
	ТипЗначенияСравнения = ТипЗнч(ЗначениеСравнения);
	Если ТипЗначенияСравнения = Тип("Строка") Тогда
		Возврат """" + ЗначениеСравнения + """";
	ИначеЕсли ТипЗначенияСравнения = Тип("Массив") ИЛИ ТипЗначенияСравнения = Тип("ФиксированныйМассив") Тогда  
		СтрРезультат = "";
		Для Каждого ЗначениеМассива Из ЗначениеСравнения Цикл
			СтрРезультат = СтрРезультат + ?(ПустаяСтрока(СтрРезультат), "", ", ") + ЗначениеВСтрокуConfluence(ЗначениеМассива);
		КонецЦикла;
		
		Возврат СтрРезультат;
	ИначеЕсли ТипЗначенияСравнения = Тип("СписокЗначений") Тогда  
		СтрРезультат = "";
		Для Каждого ЭлементСписка Из ЗначениеСравнения Цикл
			СтрРезультат = СтрРезультат + ?(ПустаяСтрока(СтрРезультат), "", ", ") + ЗначениеВСтрокуConfluence(ЭлементСписка.Значение);
		КонецЦикла;
		
		Возврат СтрРезультат;
	ИначеЕсли ТипЗначенияСравнения = Тип("Число") Тогда  
		Возврат Формат(ЗначениеСравнения, "ЧН=0; ЧГ=");
	ИначеЕсли ТипЗначенияСравнения = Тип("Дата") Тогда  
		Возврат """" + Формат(ЗначениеСравнения, "ДФ='yyyy/MM/dd HH:mm'") + """";
	ИначеЕсли ТипЗначенияСравнения = Тип("Булево") Тогда
		Возврат Формат(ЗначениеСравнения, "БЛ=false; БИ=true");
	ИначеЕсли ТипЗначенияСравнения = Тип("ПеречислениеСсылка.confluence_ТипыДанных") Тогда
		Возврат ТипДанныхВСтрокуConfluence(ЗначениеСравнения);
	Иначе
		Попытка
			Возврат Строка(ЗначениеСравнения);
		Исключение
			ВызватьИсключение СтрШаблон(НСтр("ru='Тип данных ""%1"" не поддерживается.'"), Строка(ТипЗначенияСравнения));
		КонецПопытки;
	КонецЕсли;
КонецФункции

Функция СтатусИзСтрокиConfluence(знач Соответствие, знач ПутьКлюча)
	ЗначениеСвойства = СвойствоСоответствия(Соответствие, ПутьКлюча, Неопределено);
	Если ЗначениеСвойства = Неопределено Тогда
		Возврат "";
	КонецЕсли;
	
	НРегСтатус = НРег(ЗначениеСвойства);
	
	СтруктураСтатусов = confluence_ApiClientServerReuse.content_status(Ложь); 
	Если СтруктураСтатусов.Свойство(НРегСтатус) Тогда
		Возврат СтруктураСтатусов[НРегСтатус];
	Иначе 
		Возврат "";
	КонецЕсли;
КонецФункции

Функция СтатусВСтрокуConfluence(знач Статус)
	НРегСтатус = НРег(Статус);
	
	СтруктураСтатусов = confluence_ApiClientServerReuse.content_status(Истина); 
	Если СтруктураСтатусов.Свойство(НРегСтатус) Тогда
		Возврат СтруктураСтатусов[НРегСтатус];
	Иначе 
		Возврат "";
	КонецЕсли;
КонецФункции

Функция ТипДанныхИзСтрокиConfluence(знач Соответствие, знач ПутьКлюча)
	ЗначениеСвойства = СвойствоСоответствия(Соответствие, ПутьКлюча, Неопределено);
	Если ЗначениеСвойства = Неопределено Тогда
		Возврат ПредопределенноеЗначение("Перечисление.confluence_ТипыДанных.ПустаяСсылка");
	КонецЕсли;
	
	НРегЗначениеСвойства = НРег(ЗначениеСвойства);
	Если НРегЗначениеСвойства = "page" Тогда
		Возврат ПредопределенноеЗначение("Перечисление.confluence_ТипыДанных.Статья");
	ИначеЕсли НРегЗначениеСвойства = "blogpost" Тогда
		Возврат ПредопределенноеЗначение("Перечисление.confluence_ТипыДанных.ЗаписьБлога");
	ИначеЕсли НРегЗначениеСвойства = "comment" Тогда
		Возврат ПредопределенноеЗначение("Перечисление.confluence_ТипыДанных.Комментарий");
	ИначеЕсли НРегЗначениеСвойства = "attachment" Тогда
		Возврат ПредопределенноеЗначение("Перечисление.confluence_ТипыДанных.Вложение");
	ИначеЕсли НРегЗначениеСвойства = "space" Тогда
		Возврат ПредопределенноеЗначение("Перечисление.confluence_ТипыДанных.Пространство");
	Иначе
		Возврат ПредопределенноеЗначение("Перечисление.confluence_ТипыДанных.ПустаяСсылка");
	КонецЕсли;
КонецФункции

Функция ТипДанныхВСтрокуConfluence(знач ТипДанных)
	Если ТипДанных = ПредопределенноеЗначение("Перечисление.confluence_ТипыДанных.Статья") Тогда
		Возврат "page";
	ИначеЕсли ТипДанных = ПредопределенноеЗначение("Перечисление.confluence_ТипыДанных.ЗаписьБлога") Тогда
		Возврат "blogpost";
	ИначеЕсли ТипДанных = ПредопределенноеЗначение("Перечисление.confluence_ТипыДанных.Комментарий") Тогда
		Возврат "comment";
	ИначеЕсли ТипДанных = ПредопределенноеЗначение("Перечисление.confluence_ТипыДанных.Вложение") Тогда
		Возврат "attachment";
	ИначеЕсли ТипДанных = ПредопределенноеЗначение("Перечисление.confluence_ТипыДанных.Пространство") Тогда
		Возврат "space";
	Иначе
		Возврат "";
	КонецЕсли;
КонецФункции

Функция ПолеСортировкиКонтентаВСтрокуConfluence(знач ПолеКонтента)
	НРегПолеКонтента = СокрЛП(НРег(ПолеКонтента));
	Если НРегПолеКонтента = "заголовок" Тогда
		Возврат "title";
	ИначеЕсли НРегПолеКонтента = "датасоздания" Тогда
		Возврат "contentHistory.createdDate";
	ИначеЕсли НРегПолеКонтента = "датаизменения" Тогда
		Возврат "contentHistory.lastUpdated";
	ИначеЕсли НРегПолеКонтента = "автор" Тогда
		Возврат "contentHistory.createdBy.publicName";
	КонецЕсли;
	
	Возврат "";
КонецФункции

Функция СтрокаВЧисло(знач СтрЗначение)
	Возврат СтроковыеФункцииКлиентСервер.СтрокаВЧисло(СтрЗначение);
КонецФункции

Функция СтрокаВBase64(знач Значение) Экспорт
	
	Алфавит		= "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
	Результат	= "";
	КолСимволов	= СтрДлина(Значение);
	
	МассивПодстрок	= Новый Массив;
	КолБлоков		= Цел(КолСимволов / 3);
	ОстатокСтроки	= Значение;
	Для НомерБлока = 1 По КолБлоков Цикл
		МассивПодстрок.Добавить(Лев(ОстатокСтроки, 3));
		ОстатокСтроки = Сред(ОстатокСтроки, 4);
	КонецЦикла;
	Если НЕ ПустаяСтрока(ОстатокСтроки) Тогда
		МассивПодстрок.Добавить(ОстатокСтроки);
	КонецЕсли;
	
	Для Каждого Подстрока_3 Из МассивПодстрок Цикл
		Подстрока_4 = "";
		
		// Получение числа из 3 символов
		СуммаПодстроки = 0;
		Разряд = 2;
		Пока Разряд >= 0 Цикл
			Множитель = 1;
			Для ИндексРазряда = 1 По Разряд Цикл
				Множитель = Множитель * 256;
			КонецЦикла;
			
			ЗначениеКода	= КодСимвола(Подстрока_3, 3 - Разряд);
			СуммаПодстроки	= СуммаПодстроки + ?(ЗначениеКода > 0, ЗначениеКода * Множитель, 0);
			Разряд			= Разряд - 1;
		КонецЦикла;
		
		// Получение 4 символов из числа
		Разряд = 3;
		Пока Разряд >= 0 Цикл
			Делитель = 1;
			Для ИндексРазряда = 1 По Разряд Цикл
				Делитель = Делитель * 64;
			КонецЦикла;
			
			ЗначениеКода = Цел(СуммаПодстроки / Делитель);
			Если СтрДлина(Подстрока_3) < 3 И ЗначениеКода = 0 Тогда
				ЗначениеКода = 64;
			КонецЕсли;
			
			Подстрока_4		= Подстрока_4 + Сред(Алфавит, ЗначениеКода + 1, 1);
			СуммаПодстроки	= СуммаПодстроки % Делитель;
			Разряд			= Разряд - 1;
		КонецЦикла;
		
		Результат = Результат + Подстрока_4;
	КонецЦикла;
	
	Возврат Результат;
		
КонецФункции

#КонецОбласти
 