
#Область future_methods

// https://github.com/atlassian-api/atlassian-python-api

//	page_exists(self, space, title)
//	get_child_title_list(self, page_id, type="page", start=None, limit=None)
//	get_child_id_list(self, page_id, type="page", start=None, limit=None)
//	get_page_id(self, space, title)
//	get_parent_content_id(self, page_id)
//	get_parent_content_title(self, page_id)
//	get_page_space(self, page_id)
//	get_pages_by_title(self, space, title, start=0, limit=200, expand=None)
//	get_page_by_title(self, space, title, start=0, limit=1, expand=None)
//	get_page_by_id(self, page_id, expand=None, status=None, version=None)
//	get_page_labels(self, page_id, prefix=None, start=None, limit=None)
//	get_page_comments(self, content_id, expand=None, parent_version=None, start=0, limit=25, location=None, depth=None)
//	get_draft_page_by_id(self, page_id, status="draft")
//	get_all_pages_by_label(self, label, start=0, limit=50)
//	get_all_pages_from_space_trash(self, space, start=0, limit=500, status="trashed", content_type="page")
//	get_all_draft_pages_from_space(self, space, start=0, limit=500, status="draft")
//	get_all_draft_pages_from_space_through_cql(self, space, start=0, limit=500, status="draft")
//	get_all_restrictions_for_content(self, content_id)
//	remove_page_from_trash(self, page_id)
//	remove_page_as_draft(self, page_id)
//	remove_content(self, content_id)
//	remove_page(self, page_id, status=None, recursive=False)
//	create_page(self, space, title, body, parent_id=None, type="page", representation="storage", editor=None)
//	move_page(self, space_key, page_id, target_id=None, target_title=None, position="append")
//	create_or_update_template(self, name, body, template_type="page", template_id=None, description=None, labels=None, space=None)
//	get_content_template(self, template_id)
//	get_blueprint_templates(self, space=None, start=0, limit=None, expand=None)
//	get_content_templates(self, space=None, start=0, limit=None, expand=None)
//	remove_template(self, template_id)
//	add_comment(self, page_id, text)
//	attach_content(self, content, name, content_type="application/binary", page_id=None, title=None, space=None, comment=None)
//	def attach_file(self, filename, name=None, content_type=None, page_id=None, title=None, space=None, comment=None)
//	delete_attachment(self, page_id, filename, version=None)
//	delete_attachment_by_id(self, attachment_id, version)
//	remove_page_attachment_keep_version(self, page_id, filename, keep_last_versions)
//	get_attachment_history(self, attachment_id, limit=200, start=0)
//	set_page_label(self, page_id, label)
//	remove_page_label(self, page_id, label)
//	history(self, page_id)
//	get_content_history(self, content_id)
//	get_content_history_by_version_number(self, content_id, version_number)
//	remove_content_history(self, page_id, version_number)
//	remove_page_history(self, page_id, version_number)
//	remove_content_history_in_cloud(self, page_id, version_id)
//	remove_page_history_keep_version(self, page_id, keep_last_versions)
//	has_unknown_attachment_error(self, page_id)
//	is_page_content_is_already_updated(self, page_id, body, title=None)
//	update_existing_page(self, page_id, title, body, type="page", representation="storage", minor_edit=False, version_comment=None)
//	update_page(self, page_id, title, body=None, parent_id=None, type="page", representation="storage", minor_edit=False, version_comment=None, always_update=False)
//	_insert_to_existing_page(self, page_id, title, insert_body, parent_id=None, type="page", representation="storage", minor_edit=False, version_comment=None, top_of_page=False)
//	append_page(self, page_id, title, append_body, parent_id=None, type="page", representation="storage", minor_edit=False)
//	prepend_page(self, page_id, title, prepend_body, parent_id=None, type="page", representation="storage", minor_edit=False)
//	update_or_create(self, parent_id, title, body, representation="storage", minor_edit=False, version_comment=None, editor=None)
//	convert_wiki_to_storage(self, wiki)
//	set_page_property(self, page_id, data)
//	update_page_property(self, page_id, data)
//	delete_page_property(self, page_id, page_property)
//	get_page_property(self, page_id, page_property_key)
//	get_page_properties(self, page_id)
//	get_page_ancestors(self, page_id)
//	clean_all_caches(self)
//	clean_package_cache(self, cache_name="com.gliffy.cache.gon")
//	get_all_groups(self, start=0, limit=1000)
//	get_group_members(self, group_name="confluence-users", start=0, limit=1000, expand=None)
//	get_all_members(self, group_name="confluence-users", expand=None)
//	create_space(self, space_key, space_name)
//	delete_space(self, space_key)
//	get_space_property(self, space_key, expand=None)
//	get_user_details_by_username(self, username, expand=None)
//	get_user_details_by_userkey(self, userkey, expand=None)
//	cql(self, cql, start=0, limit=None, expand=None, include_archived_spaces=None, excerpt=None)
//	export_page(self, page_id)
//	get_descendant_page_id(self, space, parent_id, title)
//	reindex(self)
//	reindex_get_status(self)
//	health_check(self)
//	synchrony_enable(self)
//	synchrony_disable(self)
//	check_access_mode(self)
//	anonymous(self)
//	upload_plugin(self, plugin_path)
//	delete_plugin(self, plugin_key)
//	check_long_tasks_result(self, start=None, limit=None, expand=None)
//	check_long_task_result(self, task_id, expand=None)
//	get_pdf_download_url_for_confluence_cloud(self, url)
//	audit(self, start_date=None, end_date=None, start=None, limit=None, search_string=None)

#КонецОбласти 

#Область ПрограммныйИнтерфейс_Общий
 
// Возвращает структуру настроек подключения
//
// Параметры:
//	ДанныеСервера	- Строка, Структура
//		Строка		- адрес сервера для получения структуры параметров подключения
//		Структура	- см. confluence_ИнтеграцияКлиентСерверПовтИсп.ПараметрыАдресаСервера
//	Логин			- Строка - логин пользователя
//	ТокенID			- Строка - токен пользователя
//
// Возвращаемое значение:
//   Структура
//		Сервер					- Строка
//		ЗащищенноеСоединение	- Булево
//		Логин					- Строка
//		ТокенID					- Строка
//		АдресСервераWiki		- Строка
// 
Функция get_connection_settings(знач ДанныеСервера, знач Логин = "", знач ТокенID = "") Экспорт
	ТипДанныхСервера = ТипЗнч(ДанныеСервера);
	Если ТипДанныхСервера = Тип("Строка") Тогда
		ПараметрыСервера = confluence_ApiClientServerReuse.url_params(ДанныеСервера);
	ИначеЕсли ТипДанныхСервера = Тип("Структура") Тогда
		ПараметрыСервера = ДанныеСервера;
	Иначе 
		ВызватьИсключение НСтр("ru='Параметр ""ДанныеСервера"" передан неверно. Обратитесь к разработчику.'");
	КонецЕсли;
	
	Настройки = Новый Структура;
	Настройки.Вставить("Сервер"					, ПараметрыСервера.СерверHTTP);
	Настройки.Вставить("ЗащищенноеСоединение"	, ПараметрыСервера.ЗащищенноеСоединение);
	Настройки.Вставить("Логин"					, Логин);
	Настройки.Вставить("ТокенID"				, ТокенID);
	Настройки.Вставить("АдресСервераWiki"		, ПараметрыСервера.АдресСервераWiki);
	Настройки.Вставить("ДанныеСессии"			, Неопределено);
	
	Возврат Настройки;
КонецФункции

// Выполняет проверку структуры на принадлженость к ошибке. Возвращает признак,
// что переданная структура - это описание ошибки. При необходимости выводит
// сообщение пользователю с текстом ошибки
//
// Параметры:
//	Структура			- Структура
//	СообщениеИсключение	- Булево - если значение не булево, ничего не происходит
//		Истина	- выводить сообщение
//		Ложь	- вызвать исключение
//
// Возвращаемое значение:
//   Булево
// 
Функция check_error(знач Структура, знач СообщениеИсключение = Неопределено) Экспорт 
	ТипСтруктуры = СвойствоСтруктуры(Структура, "type", "");
	
	ЭтоОшибка = (ТипСтруктуры = "error");
	Если НЕ ЭтоОшибка Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ДопТекст = СокрЛП(Структура.ДопТекст);
	Если НЕ ПустаяСтрока(ДопТекст) Тогда
		Если НЕ СтрЗаканчиваетсяНа(ДопТекст, ".") Тогда
			ДопТекст = ДопТекст + ".";
		КонецЕсли;
		ДопТекст = ДопТекст + " ";
	КонецЕсли;
	
	ТекстОшибки = СтрШаблон(НСтр("ru='%1Код ошибки: %2 (%3)'"),
		ДопТекст,
		Строка(Структура.Код),
		СокрЛП(Структура.Текст));
		
	Если СообщениеИсключение = Истина Тогда
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстОшибки);
	ИначеЕсли СообщениеИсключение = Ложь Тогда
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Возврат Истина;
КонецФункции

// Выполняет скачивание двоичных данных файла по указанному тексту запроса
//
// Параметры:
//	Настройки	- Структура - см. get_connection_settings
//	СтраницаИД	- Строка - идентификатор страницы
//	ВложениеИД	- Строка - идентификатор вложения
//
// Возвращаемое значение:
//   ДвоичныеДанные
//
Функция get_binarydata_file(знач Настройки, знач СтраницаИД, знач ВложениеИД) Экспорт
	Результат = get_attachment_publiclink(Настройки, СтраницаИД, ВложениеИД);
	Если НЕ ТипЗнч(Результат) = Тип("Строка") Тогда
		Возврат Результат;
	КонецЕсли;
		
	СтруктураАдреса = ОбщегоНазначенияКлиентСервер.СтруктураURI(Результат);
	
	ЗащищенноеСоединение = ?((СтруктураАдреса.Схема = "https"), Новый ЗащищенноеСоединениеOpenSSL, Неопределено);
	
	СоединениеHTTP	= Новый HTTPСоединение(СтруктураАдреса.ИмяСервера,,,,,, ЗащищенноеСоединение);
	ЗапросHTTP		= Новый HTTPЗапрос(СтруктураАдреса.ПутьНаСервере);
	
	ОтветHTTP = СоединениеHTTP.Получить(ЗапросHTTP);
	Если ОтветHTTP.КодСостояния <> 200 Тогда
		Возврат confluence_Objects.error(ОтветHTTP, НСтр("ru='Скачивание файла.'"));
	КонецЕсли;
	
	Возврат ОтветHTTP.ПолучитьТелоКакДвоичныеДанные();
КонецФункции

// Возвращает публичный адрес для скачивания вложения (без необходимости авторизации)
//
// Параметры:
//	Настройки		- Структура - см. get_connection_settings
//	СтраницаИД	- Строка - идентификатор страницы
//	ВложениеИД	- Строка - идентификатор вложения
//
// Возвращаемое значение:
//   Строка
//
Функция get_attachment_publiclink(знач Настройки, знач СтраницаИД, знач ВложениеИД) Экспорт
	ТекстЗапроса = СтрШаблон("/wiki/rest/api/content/%1/child/attachment/%2/download",
		СтраницаИД,
		ВложениеИД);
		
	Возврат get_data_publiclink(Настройки, ТекстЗапроса);
КонецФункции

// Возвращает двоичные данные результата экспорта страницы в формате PDF
//
// Параметры:
//	Настройки	- Структура - см. get_connection_settings
//	СтраницаИД	- Строка - идентификатор страницы
//
// Возвращаемое значение:
//   ДвоичныеДанные
//
Функция get_page_as_pdf(знач Настройки, знач СтраницаИД) Экспорт
	Результат = get_pdf_download_url(Настройки, СтраницаИД, "Страница");
	Если НЕ ТипЗнч(Результат) = Тип("Строка") Тогда
		Возврат Результат;
	КонецЕсли;
	
	Возврат get_binary_data(Настройки, Результат);
КонецФункции

// Возвращает двоичные данные результата экспорта страницы в формате DOC
//
// Параметры:
//	Настройки	- Структура - см. get_connection_settings
//	СтраницаИД	- Строка - идентификатор страницы
//
// Возвращаемое значение:
//   ДвоичныеДанные
//
Функция get_page_as_word(знач Настройки, знач СтраницаИД) Экспорт
	ТекстЗапроса = СтрШаблон("wiki/exportword?pageId=%1", СтраницаИД);
	
	ЗаголовкиHTTP	= ПолучитьЗаголовки(Настройки);
	ЗапросHTTP		= Новый HTTPЗапрос(ТекстЗапроса, ЗаголовкиHTTP);
	СоединениеHTTP	= ПолучитьСоединениеHTTP(Настройки);

	ОтветHTTP = СоединениеHTTP.Получить(ЗапросHTTP);
	Если ОтветHTTP.КодСостояния <> 200 Тогда
		Возврат confluence_Objects.error(ОтветHTTP, НСтр("ru='Получение ссылки для скачивания Word'"));
	КонецЕсли;
	
	Возврат ОтветHTTP.ПолучитьТелоКакДвоичныеДанные();
КонецФункции

// Вызывает функцию экспорта в PDF, дожидается выполнения и возвращает адрес ссылки
//
// Параметры:
//	Настройки		- Структура - см. get_connection_settings
//	Идентификатор	- Строка - идентификатор страницы или ключ пространства
//	Вид				- Строка - Страница или Пространство
//
// Возвращаемое значение:
//   Строка
//
Функция get_pdf_download_url(знач Настройки, знач Идентификатор, знач Вид = "Страница") Экспорт
	// API Confluence Cloud не содержит специализированного метода для получения PDF страницы
	// Однако можно воспользоваться возможностями экспорта из пользовательской части
	// 1. Получаем данные сессии (token) 
	// 2. Вызываем запуск задания для формирования PDF
	//		Статья			- ...wiki/spaces/flyingpdf/pdfpageexport.action?pageId=(ИдентификаторСтраницы)
	//		Пространство	- ...wiki/spaces/flyingpdf/doflyingpdf.action?key=(КлючПространства)
	// 3. В полученном ответе находим идентификатор задания
	// 4. По идентификатору задания регулярно опрашиваем статус выполнения
	// 5. После завершения по адресу файла возвращаем публичную ссылку для скачивания
	
	Если НРег(Вид) = "пространство" Тогда
		Шаблон = "wiki/spaces/flyingpdf/doflyingpdf.action?key=%1";
	Иначе
		Шаблон = "wiki/spaces/flyingpdf/pdfpageexport.action?pageId=%1";
	КонецЕсли;
	
	ТекстЗапроса = СтрШаблон(Шаблон, Идентификатор);
	
	ЗаголовкиHTTP	= ПолучитьЗаголовки(Настройки, "text/html;charset=UTF-8");
	ЗапросHTTP		= Новый HTTPЗапрос(ТекстЗапроса, ЗаголовкиHTTP);
	СоединениеHTTP	= ПолучитьСоединениеHTTP(Настройки);

	ОтветHTTP = СоединениеHTTP.Получить(ЗапросHTTP);
	Если ОтветHTTP.КодСостояния <> 200 Тогда
		Возврат confluence_Objects.error(ОтветHTTP, НСтр("ru='Получение ссылки для скачивания PDF'"));
	КонецЕсли;
	
	ТелоПотокДанных = ОтветHTTP.ПолучитьТелоКакПоток();
	ЧтениеHTML = Новый ЧтениеHTML;
	ЧтениеHTML.ОткрытьПоток(ТелоПотокДанных, "UTF-8");
	
	ПостроительDOM = Новый ПостроительDOM;
	ДокументHTML = ПостроительDOM.Прочитать(ЧтениеHTML);
	
	ЭлементыМетаданных = ДокументHTML.ПолучитьЭлементыПоИмени("meta");
	
	ЗадачаИД = "";
	Для Каждого Элемент Из ЭлементыМетаданных Цикл
		Если НЕ Элемент.Имя = "ajs-taskId" Тогда
			Продолжить;
		КонецЕсли;
		
		ЗадачаИД = Элемент.Содержание;
	КонецЦикла;

	Если НЕ ЗначениеЗаполнено(ЗадачаИД) Тогда
		Возврат confluence_Objects.error(ОтветHTTP, НСтр("ru='Получение номера задания для экспорта в PDF'"));
	КонецЕсли;
	
	ТекстПроверки = СтрШаблон("wiki/services/api/v1/task/%1/progress", ЗадачаИД);

	ЗаголовкиHTTP	= ПолучитьЗаголовки(Настройки);
	ЗапросHTTP		= Новый HTTPЗапрос(ТекстПроверки, ЗаголовкиHTTP);
	СоединениеHTTP	= ПолучитьСоединениеHTTP(Настройки);
	
	АдресСсылки = "";
	
	ШагОжидания	= 1;
	ВыполнятьПроверку = Истина;
	Пока ВыполнятьПроверку Цикл
		ОтветHTTP = СоединениеHTTP.Получить(ЗапросHTTP);
		Если ОтветHTTP.КодСостояния <> 200 Тогда
			Возврат confluence_Objects.error(ОтветHTTP, НСтр("ru='Получение ссылки для скачивания pdf.'"));
		КонецЕсли;
		
		Результат = СоответствиеИзОтвета(ОтветHTTP);
		
		Завершена	= (Результат.Получить("estimatedTimeRemaining") = 0);
		Успешно		= (Результат.Получить("state") = "UPLOADED_TO_S3");
		ПрошлоВремя	= Результат.Получить("timeElapsed");
		Процент		= Результат.Получить("progress");
		
		#Если Клиент Тогда
			Состояние(НСтр("ru='Экспорт данных в PDF'"),
				Число(Процент),
				НСтр("ru='Прошло: '") + ПрошлоВремя,
				БиблиотекаКартинок.Информация);
		#ИначеЕсли Сервер Тогда
			ДлительныеОперации.СообщитьПрогресс(Число(Процент),
				НСтр("ru='Прошло: '") + ПрошлоВремя);
		#КонецЕсли
		
		Если Завершена И Успешно Тогда
			АдресСсылки = Результат.Получить("result");
		КонецЕсли;
		
		Если Завершена Тогда
			ВыполнятьПроверку = Ложь;
			Прервать;
		Иначе
			ВремяКонтроль = ТекущаяУниверсальнаяДатаВМиллисекундах() + ШагОжидания*1000;
			Пока ТекущаяУниверсальнаяДатаВМиллисекундах() <= ВремяКонтроль Цикл
				// ожидание
			КонецЦикла;
			ШагОжидания = Мин(ШагОжидания + 1, 3);
		КонецЕсли;
	КонецЦикла;
	
	Если НЕ ЗначениеЗаполнено(АдресСсылки) Тогда
		Возврат confluence_Objects.error(ОтветHTTP, НСтр("ru='Ошибка определения адреса размещения файла PDF'"));
	КонецЕсли;
	
	Возврат get_data_publiclink(Настройки, АдресСсылки, 1);
КонецФункции

// Возвращает двоичные данные результата экспорта пространства в формате PDF
//
// Параметры:
//	Настройки			- Структура - см. get_connection_settings
//	КлючПространства	- Строка - ключ пространства
//
// Возвращаемое значение:
//   ДвоичныеДанные
//
Функция get_space_as_pdf(знач Настройки, знач КлючПространства) Экспорт 
	Результат = get_pdf_download_url(Настройки, КлючПространства, "Пространство");
	Если НЕ ТипЗнч(Результат) = Тип("Строка") Тогда
		Возврат Результат;
	КонецЕсли;
	
	Возврат get_binary_data(Настройки, Результат);
КонецФункции

// Возвращает двоичные данные результата экспорта пространства в формате ZIP
// Внутри ZIP архива располагаются данные в формате XML, подходят для импорта
//
// Параметры:
//	Настройки			- Структура - см. get_connection_settings
//	КлючПространства	- Строка - ключ пространства
//
// Возвращаемое значение:
//   ДвоичныеДанные
//
Функция get_space_as_xml(знач Настройки, знач КлючПространства) Экспорт 
	Результат = get_space_xml_download_url(Настройки, КлючПространства);
	Если НЕ ТипЗнч(Результат) = Тип("Строка") Тогда
		Возврат Результат;
	КонецЕсли;
	
	Возврат get_binary_data(Настройки, Результат);
КонецФункции

// Вызывает функцию экспорта пространства в XML, дожидается выполнения и возвращает адрес ссылки
//
// Параметры:
//	Настройки			- Структура - см. get_connection_settings
//	КлючПространства	- Строка - ключ пространства
//
// Возвращаемое значение:
//   Строка
//
Функция get_space_xml_download_url(знач Настройки, знач КлючПространства) Экспорт
	// API Confluence Cloud не содержит специализированного метода для получения XML выгрузки пространства
	// Однако можно воспользоваться возможностями экспорта из пользовательской части
	// 1. Получаем данные сессии (token) 
	// 2. Вызываем запуск задания для формирования PDF
	//		.../wiki/spaces/doexportspace.action?key=(КлючПространства) 
	//		+ FormData: atl_token=[ТокенДоступа]&exportType=TYPE_XML&contentOption=all&includeComments=true&confirm=[Экспорт]
	// 3. В полученном ответе находим ссылку для проверки статуса задания (meta ajs-pollURI)
	// 4. По идентификатору задания регулярно опрашиваем статус выполнения
	// 5. После завершения по адресу файла возвращаем публичную ссылку для скачивания
	
	//Результат = check_session_data(Настройки);
	//Если НЕ Результат.Выполнено Тогда
	//	Возврат Результат.ДанныеОшибки;
	//КонецЕсли;
	
	// Подстановку Настройки.ДанныеСессии.token делать не обязательно
	ТелоЗапроса = СтрШаблон("atl_token=%1&exportType=TYPE_XML&contentOption=all&includeComments=true&confirm=%2",
		"", 
		"%D0%AD%D0%BA%D1%81%D0%BF%D0%BE%D1%80%D1%82");
		
	ТекстЗапроса = СтрШаблон("wiki/spaces/doexportspace.action?key=%1",
		КлючПространства);
		
	ДвоичныеДанные = ПолучитьДвоичныеДанныеИзСтроки(ТелоЗапроса);
	
	ЗаголовкиHTTP = ПолучитьЗаголовки(Настройки, "application/x-www-form-urlencoded");
	ЗаголовкиHTTP.Вставить("content-length", ДвоичныеДанные.Размер());
	
	СоединениеHTTP	= ПолучитьСоединениеHTTP(Настройки);
	
	ЗапросHTTP = Новый HTTPЗапрос(ТекстЗапроса, ЗаголовкиHTTP);
	ЗапросHTTP.УстановитьТелоИзСтроки(ТелоЗапроса);
	
	ОтветHTTP = СоединениеHTTP.ОтправитьДляОбработки(ЗапросHTTP);
	Если ОтветHTTP.КодСостояния <> 200 Тогда
		Возврат confluence_Objects.error(ОтветHTTP, НСтр("ru='Получение ссылки для скачивания ZIP архива XML'"));
	КонецЕсли;
	
	ТелоПотокДанных = ОтветHTTP.ПолучитьТелоКакПоток();
	ЧтениеHTML = Новый ЧтениеHTML;
	ЧтениеHTML.ОткрытьПоток(ТелоПотокДанных, "UTF-8");
	
	ПостроительDOM = Новый ПостроительDOM;
	ДокументHTML = ПостроительDOM.Прочитать(ЧтениеHTML);
	
	ЭлементыМетаданных = ДокументHTML.ПолучитьЭлементыПоИмени("meta");
	
	ТекстПроверки = "";
	Для Каждого Элемент Из ЭлементыМетаданных Цикл
		Если НЕ Элемент.Имя = "ajs-pollURI" Тогда
			Продолжить;
		КонецЕсли;
		
		ТекстПроверки = Элемент.Содержание;
	КонецЦикла;

	Если НЕ ЗначениеЗаполнено(ТекстПроверки) Тогда
		Возврат confluence_Objects.error(ОтветHTTP, НСтр("ru='Получение ссылки длительного задания для экспорта в XML'"));
	КонецЕсли;
	
	Если НЕ СтрНачинаетсяС(ТекстПроверки, "wiki") Тогда
		ТекстПроверки = "wiki/" + ТекстПроверки;
	КонецЕсли;

	ЗаголовкиHTTP	= ПолучитьЗаголовки(Настройки);
	ЗапросHTTP		= Новый HTTPЗапрос(ТекстПроверки, ЗаголовкиHTTP);
	СоединениеHTTP	= ПолучитьСоединениеHTTP(Настройки);
	
	АдресСсылки = "";
	
	ШагОжидания	= 1;
	ВыполнятьПроверку = Истина;
	Пока ВыполнятьПроверку Цикл
		ОтветHTTP = СоединениеHTTP.Получить(ЗапросHTTP);
		Если ОтветHTTP.КодСостояния <> 200 Тогда
			Возврат confluence_Objects.error(ОтветHTTP, НСтр("ru='Получение ссылки для скачивания zip архива с данными XML.'"));
		КонецЕсли;
		
		ДанныеОтвета = СоответствиеИзОтвета(ОтветHTTP);
		
		Завершена	= СвойствоСоответствия(ДанныеОтвета, "complete", Ложь);
		Успешно		= СвойствоСоответствия(ДанныеОтвета, "successful", Ложь);
		ПрошлоВремя	= СвойствоСоответствия(ДанныеОтвета, "elapsedTime", 0, Истина);
		Процент		= СвойствоСоответствия(ДанныеОтвета, "percentageComplete", 0, Истина);
		АдресСсылки	= СвойствоСоответствия(ДанныеОтвета, "result", "");
		
		ПрошлоВремя = ПрошлоВремя / 1000;
		Если ПрошлоВремя > 60 Тогда
			ПрошлоВремя = Формат(Цел(ПрошлоВремя / 60), "ЧГ=;ЧН=0") + НСтр("ru=' мин.'");
		Иначе 
			ПрошлоВремя = Формат(ПрошлоВремя, "ЧГ=;ЧН=0") + НСтр("ru=' сек.'");
		КонецЕсли;
		
		#Если Клиент Тогда
			Состояние(НСтр("ru='Экспорт данных пространства в XML'"),
				Число(Процент),
				НСтр("ru='Прошло: '") + ПрошлоВремя,
				БиблиотекаКартинок.Информация);
		#ИначеЕсли Сервер Тогда
			ДлительныеОперации.СообщитьПрогресс(Число(Процент),
				НСтр("ru='Прошло: '") + ПрошлоВремя);
		#КонецЕсли
		
		Если Завершена Тогда
			ВыполнятьПроверку = Ложь;
			Прервать;
		Иначе
			ВремяКонтроль = ТекущаяУниверсальнаяДатаВМиллисекундах() + ШагОжидания*1000;
			Пока ТекущаяУниверсальнаяДатаВМиллисекундах() <= ВремяКонтроль Цикл
				// ожидание
			КонецЦикла;
			ШагОжидания = Мин(ШагОжидания + 1, 3);
		КонецЕсли;
	КонецЦикла;
	
	Если НЕ ЗначениеЗаполнено(АдресСсылки) Тогда
		Возврат confluence_Objects.error(ОтветHTTP, НСтр("ru='Ошибка определения адреса размещения файла zip архива с данными XML'"));
	КонецЕсли;
	
	Возврат get_data_publiclink(Настройки, АдресСсылки);
КонецФункции

// Вычисляет публичную ссылку для скачивания файла без необходимости авторизации
//
// Параметры:
//	Настройки		- Структура - см. get_connection_settings
//	ТекстЗапроса	- Строка - текст запроса 
//	Вариант			- Число - 
//		0 - запрос к /wiki/download/...
//		1 - получение данных файла PDF
//
// Возвращаемое значение:
//   Строка
//
Функция get_data_publiclink(знач Настройки, знач ТекстЗапроса, знач Вариант = 0) Экспорт
	#Область ЗапросHTTP
	ЗаголовкиHTTP	= ПолучитьЗаголовки(Настройки);
	ЗапросHTTP		= Новый HTTPЗапрос(ТекстЗапроса, ЗаголовкиHTTP);
	СоединениеHTTP	= ПолучитьСоединениеHTTP(Настройки);
	#КонецОбласти 
	
	ОтветHTTP = СоединениеHTTP.Получить(ЗапросHTTP);
	Если Вариант = 0 И ОтветHTTP.КодСостояния <> 302 Тогда
		Возврат confluence_Objects.error(ОтветHTTP, НСтр("ru='Проверка наличия данных для скачивания (0).'"));
	ИначеЕсли Вариант = 1 И ОтветHTTP.КодСостояния <> 200 Тогда
		Возврат confluence_Objects.error(ОтветHTTP, НСтр("ru='Проверка наличия данных для скачивания (1).'"));
	КонецЕсли;
	
	Если Вариант = 0 Тогда
		АдресФайла = СвойствоСоответствия(ОтветHTTP.Заголовки, "location", "");
		Если НЕ ЗначениеЗаполнено(АдресФайла) Тогда
			АдресФайла = СвойствоСоответствия(ОтветHTTP.Заголовки, "Location", "");
		КонецЕсли;
	ИначеЕсли Вариант = 1 Тогда 
		АдресФайла = ОтветHTTP.ПолучитьТелоКакСтроку();
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(АдресФайла) Тогда
		ВсеЗаголовки = Новый Массив;;
		Для Каждого КлючИЗначение Из ОтветHTTP.Заголовки Цикл
			ВсеЗаголовки.Добавить(КлючИЗначение.Ключ);
		КонецЦикла;
		
		ТекстОписания = СтрШаблон(НСтр("ru='Адрес переадресации не определен (все заголовки %1).'"), СтрСоединить(ВсеЗаголовки, "; "));
		Возврат confluence_Objects.error(ОтветHTTP, ТекстОписания);
	КонецЕсли;

	Возврат АдресФайла;
КонецФункции

// Возвращает полный адрес страницы из сокращенного
//
// Параметры:
//	Настройки	- Структура - см. get_connection_settings
//	КороткийURL - Строка
//
// Возвращаемое значение:
//   Строка
//
Функция get_long_url(знач Настройки, знач КороткийURL) Экспорт
	СтруктураАдреса = ОбщегоНазначенияКлиентСервер.СтруктураURI(КороткийURL);
	
	ЗащищенноеСоединение = ?((СтруктураАдреса.Схема = "https"), Новый ЗащищенноеСоединениеOpenSSL, Неопределено);
	
	СоединениеHTTP	= Новый HTTPСоединение(СтруктураАдреса.ИмяСервера,,,,,, ЗащищенноеСоединение);
	ЗапросHTTP		= Новый HTTPЗапрос(СтруктураАдреса.ПутьНаСервере);
	
	ОтветHTTP = СоединениеHTTP.Получить(ЗапросHTTP);
	Если ОтветHTTP.КодСостояния <> 302 Тогда
		Возврат confluence_Objects.error(ОтветHTTP, НСтр("ru='Определение полного адреса ссылки.'"));
	КонецЕсли;
	
	ПолныйURL = СвойствоСоответствия(ОтветHTTP.Заголовки, "location", "");
	Если НЕ ЗначениеЗаполнено(ПолныйURL) Тогда
		ПолныйURL = СвойствоСоответствия(ОтветHTTP.Заголовки, "Location", "");
	КонецЕсли;
	
	Возврат ?(НЕ ТипЗнч(ПолныйURL) = Тип("Строка"), "", ПолныйURL);
КонецФункции

// Выполняет проверку данных сессии, требуется для получения токена доступа
//
// Параметры:
//	Настройки - Структура - см. get_connection_settings
//
// Возвращаемое значение:
//   Структура
//		Выполнено		- Булево
//		ДанныеОшибки	- Структура, Неопределено - структура type = error
//
Функция check_session_data(знач Настройки) Экспорт
	Результат = Новый Структура("Выполнено,ДанныеОшибки", Ложь, Неопределено);
	
	Если ТипЗнч(Настройки.ДанныеСессии) = Тип("Структура")
		И Настройки.ДанныеСессии.Свойство("token")
		И ЗначениеЗаполнено(Настройки.ДанныеСессии.token) Тогда
		Результат.Выполнено = Истина;

		Возврат Результат;
	КонецЕсли;
	
	ДанныеСессии = get_session_data(Настройки);
	Если НЕ ТипЗнч(ДанныеСессии) = Тип("Структура") ИЛИ ДанныеСессии.type <> "sessiondata" Тогда
		Результат.ДанныеОшибки = ДанныеСессии;
		Возврат Результат;
	КонецЕсли;
		
	Результат.Выполнено = Истина;
	Настройки.ДанныеСессии = ДанныеСессии;
	
	Возврат Результат;
КонецФункции

// Получает данные сессии из запроса к основной странице
//
// Параметры:
//	Настройки - Структура - см. get_connection_settings
//
// Возвращаемое значение:
//   Структура - type = sessiondata
//		cookie	- Строка
//		token	- Строка
//
Функция get_session_data(знач Настройки) Экспорт
	#Область ЗапросHTTP
	ЗаголовкиHTTP	= ПолучитьЗаголовки(Настройки);
	ЗапросHTTP		= Новый HTTPЗапрос("wiki", ЗаголовкиHTTP);
	СоединениеHTTP	= ПолучитьСоединениеHTTP(Настройки);
	#КонецОбласти 
	
	ОтветHTTP = СоединениеHTTP.Получить(ЗапросHTTP);
	Если ОтветHTTP.КодСостояния <> 200 Тогда
		Возврат confluence_Objects.error(ОтветHTTP, НСтр("ru='Получение данных cookie для сессии.'"));
	КонецЕсли;
	
	ДанныеCookie = "";
	Для Каждого КлючИЗначение Из ОтветHTTP.Заголовки Цикл
		Если НРег(КлючИЗначение.Ключ) = НРег("Set-Cookie") Тогда
			ДанныеCookie = КлючИЗначение.Значение;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	ИдентификаторСессии = ЗначениеПараметраИзСтроки(ДанныеCookie, "JSESSIONID");
	ЗначениеТокена		= ЗначениеПараметраИзСтроки(ДанныеCookie, "atl.xsrf.token");
	
	ЗначениеCookie = Новый Массив;
	Если ЗначениеЗаполнено(ИдентификаторСессии) Тогда
		ЗначениеCookie.Добавить("JSESSIONID=" + ИдентификаторСессии);
	КонецЕсли;
	Если ЗначениеЗаполнено(ЗначениеТокена) Тогда
		ЗначениеCookie.Добавить("atl.xsrf.token=" + ЗначениеТокена);
	КонецЕсли;
	
	Возврат Новый Структура("type, cookie, token",
		"sessiondata",
		СтрСоединить(ЗначениеCookie, "; "),
		ЗначениеТокена);
КонецФункции

// Выполняет получение двоичных данных по ссылке
//
// Параметры:
//	Настройки 	- Структура - см. get_connection_settings
//	АдресСсылки - Строка
//
// Возвращаемое значение:
//   ДвоичныеДанные, Структура(type=error)
//
Функция get_binary_data(знач Настройки, знач АдресСсылки) Экспорт
	СтруктураАдреса = ОбщегоНазначенияКлиентСервер.СтруктураURI(АдресСсылки);
	ЗащищенноеСоединение = ?((СтруктураАдреса.Схема = "https"), Новый ЗащищенноеСоединениеOpenSSL, Неопределено);
	
	ЗаголовкиHTTP	= ПолучитьЗаголовки(Настройки);
	СоединениеHTTP	= Новый HTTPСоединение(СтруктураАдреса.ИмяСервера,,,,,, ЗащищенноеСоединение);
	ЗапросHTTP		= Новый HTTPЗапрос(СтруктураАдреса.ПутьНаСервере, ЗаголовкиHTTP);
	
	ОтветHTTP = СоединениеHTTP.Получить(ЗапросHTTP);
	Если ОтветHTTP.КодСостояния <> 200 Тогда
		Возврат confluence_Objects.error(ОтветHTTP, НСтр("ru='Скачивание файла.'"));
	КонецЕсли;
	
	Возврат ОтветHTTP.ПолучитьТелоКакДвоичныеДанные();
КонецФункции

#КонецОбласти

#Область ПрограммныйИнтерфейс_spaces

// Возвращает все пространства. Список упорядочен в алфавитном порядке в порядке возрастания по ключу
//
// Параметры:
//	Настройки			- Структура - см. get_connection_settings
//	ПараметрыЗапроса	- Структура	- см. get_all_spaces_params
//
// Возвращаемое значение:
//   Структура - type = spacearray
// 
Функция get_all_spaces(знач Настройки, знач ПараметрыЗапроса = Неопределено) Экспорт
	СтрокаПараметры = ПараметрыЗапроса_get_all_spaces(ПараметрыЗапроса);
	СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "expand", "description.view,metadata.labels,homepage,permissions");
	СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "status", "current");
	
	ТекстЗапроса = "/wiki/rest/api/space?" + СтрокаПараметры;
	
	#Область ЗапросHTTP
	ЗаголовкиHTTP	= ПолучитьЗаголовки(Настройки);
	ЗапросHTTP		= Новый HTTPЗапрос(ТекстЗапроса, ЗаголовкиHTTP);
	СоединениеHTTP	= ПолучитьСоединениеHTTP(Настройки);
	#КонецОбласти 
	
	ОтветHTTP = СоединениеHTTP.Получить(ЗапросHTTP);
	Если ОтветHTTP.КодСостояния <> 200 Тогда
		Возврат confluence_Objects.error(ОтветHTTP, НСтр("ru='Получение всех пространств.'"));
	КонецЕсли;
	
	ДанныеОтвета = СоответствиеИзОтвета(ОтветHTTP);
	Возврат confluence_Objects.spacearray(ДанныеОтвета, Настройки);
КонецФункции

// Возвращает все страницы из пространства
//
// Параметры:
//	Настройки			- Структура - см. get_connection_settings
//	КлючПространства	- Строка - ключ пространства (confluence_Objects.space.Ключ)
//	ПараметрыЗапроса	- Структура - см. get_all_pages_from_space_params
//
// Возвращаемое значение:
//   Структура - type = contentarray
//		body_storage - не предоставляется
// 
Функция get_all_pages_from_space(знач Настройки, знач КлючПространства, знач ПараметрыЗапроса = Неопределено) Экспорт
	СтрокаПараметры = ПараметрыЗапроса_get_all_pages_from_space(ПараметрыЗапроса);
	СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "type", "page");
	СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "spaceKey", КлючПространства);
	
	ТекстЗапроса = "/wiki/rest/api/content?" + СтрокаПараметры;
	
	#Область ЗапросHTTP
	ЗаголовкиHTTP	= ПолучитьЗаголовки(Настройки);
	ЗапросHTTP		= Новый HTTPЗапрос(ТекстЗапроса, ЗаголовкиHTTP);
	СоединениеHTTP	= ПолучитьСоединениеHTTP(Настройки);
	#КонецОбласти 
	
	ОтветHTTP = СоединениеHTTP.Получить(ЗапросHTTP);
	Если ОтветHTTP.КодСостояния <> 200 Тогда
		Возврат confluence_Objects.error(ОтветHTTP, НСтр("ru='Получение всех страниц раздела.'"));
	КонецЕсли;
	
	ДанныеОтвета = СоответствиеИзОтвета(ОтветHTTP);
	Возврат confluence_Objects.contentarray(ДанныеОтвета, Настройки);
КонецФункции

// Возвращает данные пространства
//
// Параметры:
//	Настройки			- Структура - см. get_connection_settings
//	КлючПространства	- Строка - ключ пространства (confluence_Objects.space.Ключ)
//
// Возвращаемое значение:
//   Структура - type = space
// 
Функция get_space(знач Настройки, знач КлючПространства) Экспорт
	СтрокаПараметры = "";
	СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "expand", "description.view,metadata.labels,homepage");
	
	ТекстЗапроса = СтрШаблон("/wiki/rest/api/space/%1?%2", КлючПространства, СтрокаПараметры);
	
	#Область ЗапросHTTP
	ЗаголовкиHTTP	= ПолучитьЗаголовки(Настройки);
	ЗапросHTTP		= Новый HTTPЗапрос(ТекстЗапроса, ЗаголовкиHTTP);
	СоединениеHTTP	= ПолучитьСоединениеHTTP(Настройки);
	#КонецОбласти 
	
	ОтветHTTP = СоединениеHTTP.Получить(ЗапросHTTP);
	Если ОтветHTTP.КодСостояния <> 200 Тогда
		Возврат confluence_Objects.error(ОтветHTTP, НСтр("ru='Получение данных пространства.'"));
	КонецЕсли;
	
	ДанныеОтвета = СоответствиеИзОтвета(ОтветHTTP);
	Возврат confluence_Objects.space(ДанныеОтвета, Настройки);
КонецФункции

// Возвращает все страницы из пространства
//
// Параметры:
//	Настройки			- Структура - см. get_connection_settings
//	КлючПространства	- Строка - ключ пространства (confluence_Objects.space.Ключ)
//	ПараметрыЗапроса	- Структура - см. get_space_content_params
//
// Возвращаемое значение:
//   Структура - type = contentarray
//		В том числе body_storage
// 
Функция get_space_content(знач Настройки, знач КлючПространства, знач ПараметрыЗапроса = Неопределено) Экспорт
	СтрокаПараметры = ПараметрыЗапроса_get_space_content(ПараметрыЗапроса);
	
	ТекстЗапроса = СтрШаблон("/wiki/rest/api/space/%1/content/%2?%3", Формат(КлючПространства, "ЧГ="), "page", СтрокаПараметры);
	
	#Область ЗапросHTTP
	ЗаголовкиHTTP	= ПолучитьЗаголовки(Настройки);
	ЗапросHTTP		= Новый HTTPЗапрос(ТекстЗапроса, ЗаголовкиHTTP);
	СоединениеHTTP	= ПолучитьСоединениеHTTP(Настройки);
	#КонецОбласти 
	
	ОтветHTTP = СоединениеHTTP.Получить(ЗапросHTTP);
	Если ОтветHTTP.КодСостояния <> 200 Тогда
		Возврат confluence_Objects.error(ОтветHTTP, НСтр("ru='Получение контента раздела.'"));
	КонецЕсли;
	
	ДанныеОтвета = СоответствиеИзОтвета(ОтветHTTP);
	Возврат confluence_Objects.contentarray(ДанныеОтвета, Настройки);
КонецФункции

// Возвращает структуру основной страницы пространства
//
// Параметры:
//	Настройки			- Структура - см. get_connection_settings
//	КлючПространства	- Строка - ключ пространства (confluence_Objects.space.Ключ)
//
// Возвращаемое значение:
//   Структура - type = homepage
// 
Функция get_home_page_of_space(знач Настройки, знач КлючПространства) Экспорт
	Результат = get_space(Настройки, КлючПространства);	
	Если check_error(Результат, Неопределено) Тогда
		Возврат Результат;
	КонецЕсли;
	
	Возврат Результат.ДомашняяСтраница;
КонецФункции

#КонецОбласти

#Область ПрограммныйИнтерфейс_pages

// Возвращает подчиненные данные по родителю и типу
//
// Параметры:
//	Настройки			- Структура - см. get_connection_settings
//	РодительИД			- Строка - идентификатор родителя
//	ТипДанных			- ПеречислениеСсылка.confluence_ТипыДанных
//	ПараметрыЗапроса	- Структура - см. get_page_child_by_type_params
//
// Возвращаемое значение:
//   Структура - type = contentarray
// 
Функция get_page_child_by_type(знач Настройки, знач РодительИД, знач ТипДанных, знач ПараметрыЗапроса = Неопределено) Экспорт
	СтрокаПараметры = ПараметрыЗапроса_get_page_child_by_type(ПараметрыЗапроса);
	ТипКонтента		= ТипДанныхВСтрокуConfluence(ТипДанных);
	
	ТекстЗапроса = СтрШаблон("/wiki/rest/api/content/%1/child/%2?%3", РодительИД, ТипКонтента, СтрокаПараметры);
	
	#Область ЗапросHTTP
	ЗаголовкиHTTP	= ПолучитьЗаголовки(Настройки);
	ЗапросHTTP		= Новый HTTPЗапрос(ТекстЗапроса, ЗаголовкиHTTP);
	СоединениеHTTP	= ПолучитьСоединениеHTTP(Настройки);
	#КонецОбласти 
	
	ОтветHTTP = СоединениеHTTP.Получить(ЗапросHTTP);
	Если ОтветHTTP.КодСостояния <> 200 Тогда
		Возврат confluence_Objects.error(ОтветHTTP, НСтр("ru='Получение подчиненных страниц по типу.'"));
	КонецЕсли;
	
	ДанныеОтвета = СоответствиеИзОтвета(ОтветHTTP);
	Возврат confluence_Objects.contentarray(ДанныеОтвета, Настройки);
КонецФункции

// Возвращает все подчиненные статьи по родителю
//
// Параметры:
//	Настройки			- Структура - см. get_connection_settings
//	РодительИД			- Строка - идентификатор родителя
//
// Возвращаемое значение:
//   Структура - type = contentarray
//		body_storage - не предоставляется
// 
Функция get_child_pages(знач Настройки, знач РодительИД) Экспорт
	ТипСтатья = ПредопределенноеЗначение("Перечисление.confluence_ТипыДанных.Статья");
	Возврат get_page_child_by_type(Настройки, РодительИД, ТипСтатья);
КонецФункции

// Возвращает данные меток по статье
//
// Параметры:
//	Настройки			- Структура - см. get_connection_settings
//	СтраницаИД			- Строка - идентификатор страницы
//	ПараметрыЗапроса	- Структура - см. get_page_labels_params
//
// Возвращаемое значение:
//   Структура - type = labelarray
// 
Функция get_page_labels(знач Настройки, знач СтраницаИД, знач ПараметрыЗапроса = Неопределено) Экспорт
	СтрокаПараметры = ПараметрыЗапроса_get_page_labels(ПараметрыЗапроса);
	
	ТекстЗапроса = СтрШаблон("/wiki/rest/api/content/%1/label?%2", СтраницаИД, СтрокаПараметры);
	
	#Область ЗапросHTTP
	ЗаголовкиHTTP	= ПолучитьЗаголовки(Настройки);
	ЗапросHTTP		= Новый HTTPЗапрос(ТекстЗапроса, ЗаголовкиHTTP);
	СоединениеHTTP	= ПолучитьСоединениеHTTP(Настройки);
	#КонецОбласти 
	
	ОтветHTTP = СоединениеHTTP.Получить(ЗапросHTTP);
	Если ОтветHTTP.КодСостояния <> 200 Тогда
		Возврат confluence_Objects.error(ОтветHTTP, НСтр("ru='Получение меток по странице.'"));
	КонецЕсли;
	
	ДанныеОтвета = СоответствиеИзОтвета(ОтветHTTP);
	Возврат confluence_Objects.labelarray(ДанныеОтвета);
КонецФункции

#КонецОбласти

#Область ПрограммныйИнтерфейс_content

// Возвращает контент страницы по ее идентификатору
// При этом структура данных содержит заполненный реквизит body_storage
//
// Параметры:
//	Настройки	- Структура - см. get_connection_settings
//	СтраницаИД	- Строка - идентификатор страницы
//
// Возвращаемое значение:
//   Структура - type = content
// 
Функция get_page_content(знач Настройки, знач СтраницаИД, знач ПараметрыЗапроса = Неопределено) Экспорт
	СтрокаПараметры = ПараметрыЗапроса_get_page_content(ПараметрыЗапроса);
	
	ТекстЗапроса = СтрШаблон("/wiki/rest/api/content/%1?%2", СтраницаИД, СтрокаПараметры);
	
	#Область ЗапросHTTP
	ЗаголовкиHTTP	= ПолучитьЗаголовки(Настройки);
	ЗапросHTTP		= Новый HTTPЗапрос(ТекстЗапроса, ЗаголовкиHTTP);
	СоединениеHTTP	= ПолучитьСоединениеHTTP(Настройки);
	#КонецОбласти 
	
	ОтветHTTP = СоединениеHTTP.Получить(ЗапросHTTP);
	Если ОтветHTTP.КодСостояния <> 200 Тогда
		Возврат confluence_Objects.error(ОтветHTTP, НСтр("ru='Получение контента страницы.'"));
	КонецЕсли;
	
	ДанныеОтвета = СоответствиеИзОтвета(ОтветHTTP);
	Возврат confluence_Objects.content(ДанныеОтвета, Настройки);
КонецФункции

// Выполняет конвертацию страницы в HTML код
//
// Параметры:
//	Настройки			- Структура - см. get_connection_settings
//	СтруктураContent	- Структура - type = content
//
// Возвращаемое значение:
//   Строка
// 
Функция convert_storage_to_view(знач Настройки, знач СтруктураContent) Экспорт
	СтрокаПараметры = "";
	СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "spaceKeyContext", СтруктураContent.Пространство.Ключ);
	СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "contentIdContext", СтруктураContent.Идентификатор);
	
	ТекстЗапроса = "/wiki/rest/api/contentbody/convert/styled_view?" + СтрокаПараметры;
	
	#Область СтрокаJSON
	СтруктураДанных = Новый Структура;
	СтруктураДанных.Вставить("value"			, СтруктураContent.body_storage);
	СтруктураДанных.Вставить("representation"	, "storage");
	
	СтрокаJSON = ПолучитьСтрокуJSON(СтруктураДанных);
	#КонецОбласти 
	
	#Область ЗапросHTTP
	ЗаголовкиHTTP	= ПолучитьЗаголовки(Настройки);
	ЗапросHTTP		= Новый HTTPЗапрос(ТекстЗапроса, ЗаголовкиHTTP);
	ЗапросHTTP.УстановитьТелоИзСтроки(СтрокаJSON);
	СоединениеHTTP	= ПолучитьСоединениеHTTP(Настройки);
	#КонецОбласти 
	
	ОтветHTTP = СоединениеHTTP.ОтправитьДляОбработки(ЗапросHTTP);
	Если ОтветHTTP.КодСостояния <> 200 Тогда
		Возврат confluence_Objects.error(ОтветHTTP, НСтр("ru='Конвертация контента'"));
	КонецЕсли;
	
	ДанныеОтвета = СоответствиеИзОтвета(ОтветHTTP);
	Возврат СвойствоСоответствия(ДанныеОтвета, "value", "");
КонецФункции

#КонецОбласти

#Область ПрограммныйИнтерфейс_attachments

// Возвращает вложения по указанной странице
//
// Параметры:
//	Настройки	- Структура - см. get_connection_settings
//	СтраницаИД	- Строка - идентификатор страницы
//
// Возвращаемое значение:
//   Структура - type = attachments
// 
Функция get_attachments_from_content(знач Настройки, знач СтраницаИД, знач ПараметрыЗапроса = Неопределено) Экспорт
	СтрокаПараметры = ПараметрыЗапроса_get_attachments_from_content(ПараметрыЗапроса);
	
	ТекстЗапроса = СтрШаблон("/wiki/rest/api/content/%1/child/attachment?%2", СтраницаИД, СтрокаПараметры);
	
	#Область ЗапросHTTP
	ЗаголовкиHTTP	= ПолучитьЗаголовки(Настройки);
	ЗапросHTTP		= Новый HTTPЗапрос(ТекстЗапроса, ЗаголовкиHTTP);
	СоединениеHTTP	= ПолучитьСоединениеHTTP(Настройки);
	#КонецОбласти 
	
	ОтветHTTP = СоединениеHTTP.Получить(ЗапросHTTP);
	Если ОтветHTTP.КодСостояния <> 200 Тогда
		Возврат confluence_Objects.error(ОтветHTTP, НСтр("ru='Получение подчиненных страниц по типу.'"));
	КонецЕсли;
	
	ДанныеОтвета = СоответствиеИзОтвета(ОтветHTTP);
	Возврат confluence_Objects.attachments(ДанныеОтвета);
КонецФункции

#КонецОбласти

#Область ПрограммныйИнтерфейс_cql

// Возвращает контент страницы по ее идентификатору
// При этом структура данных содержит заполненный реквизит body_storage
//
// Параметры:
//	Настройки			- Структура - см. get_connection_settings
//	ТекстОтбора			- Строка - см. get_cql_filter_text
//	ТекстПорядка		- Строка - см. get_cql_order_text
//	ПараметрыЗапроса	- Структура
//
// Возвращаемое значение:
//   Структура - type = content
//		В том числе body_storage
// 
Функция cql(знач Настройки, знач ТекстОтбора, знач ТекстПорядка, знач ПараметрыЗапроса = Неопределено) Экспорт
	СтрокаПараметры = ПараметрыЗапроса_cql(ПараметрыЗапроса);
	СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "cql", ТекстОтбора + ТекстПорядка);
	
	ТекстЗапроса = СтрШаблон("/wiki/rest/api/search?%1", СтрокаПараметры);
	
	#Область ЗапросHTTP
	ЗаголовкиHTTP	= ПолучитьЗаголовки(Настройки);
	ЗапросHTTP		= Новый HTTPЗапрос(ТекстЗапроса, ЗаголовкиHTTP);
	СоединениеHTTP	= ПолучитьСоединениеHTTP(Настройки);
	#КонецОбласти 
	
	ОтветHTTP = СоединениеHTTP.Получить(ЗапросHTTP);
	Если ОтветHTTP.КодСостояния <> 200 Тогда
		Возврат confluence_Objects.error(ОтветHTTP, НСтр("ru='Получение контента страницы.'"));
	КонецЕсли;
	
	ДанныеОтвета = СоответствиеИзОтвета(ОтветHTTP);
	Возврат confluence_Objects.searchresult(ДанныеОтвета, Настройки);
КонецФункции

// Добавляет элемент поиска в группу или настройку отбора
//
// Параметры:
//	Коллекция	- Массив, Структура - массив отбора или группа отбора (см. cql_filterGroup)
//	ПолеПоиска	- Структура, ПеречислениеСсылка.confluence_ПоляCQL - может быть передан готовый элемент
//		отбора (см. cql_filterItem) или данные для формирования элемента отбора
//	Условие		- ВидСравненияКомпоновкиДанных
//	Значение	- Произвольный, Массив
// 
Процедура cql_addFilterItem(Коллекция, знач ПолеПоиска, знач Условие = Неопределено, знач Значение = Неопределено) Экспорт
	ТипПолеПоиска = ТипЗнч(ПолеПоиска);
	Если ТипПолеПоиска = Тип("Структура") И ПолеПоиска.Свойство("type") И ПолеПоиска.type = "cqlFilterItem" Тогда
		ЭлементПоиска = ПолеПоиска;
	ИначеЕсли ТипПолеПоиска = Тип("ПеречислениеСсылка.confluence_ПоляCQL") Тогда 
		ЭлементПоиска = cql_filterItem(ПолеПоиска, Условие, Значение);
	КонецЕсли;
	
	ТипКоллекция = ТипЗнч(Коллекция);
	Если ТипКоллекция = Тип("Массив") Тогда
		Коллекция.Добавить(ЭлементПоиска);
	ИначеЕсли ТипКоллекция = Тип("Структура") И Коллекция.Свойство("Элементы") Тогда
		Коллекция.Элементы.Добавить(ЭлементПоиска);
	КонецЕсли;
КонецПроцедуры

// Добавляет элемент порядка в коллекцию "Порядок" (см.cql_params) 
//
// Параметры:
//	МассивПорядок	- Массив
//	Поле			- ПеречислениеСсылка.confluence_ПоляCQL
//	Направление		- НаправлениеСортировкиКомпоновкиДанных
// 
Процедура cql_addOrderItem(МассивПорядок, знач Поле, знач Направление = Неопределено) Экспорт
	Если НЕ ТипЗнч(Направление) = Тип("НаправлениеСортировкиКомпоновкиДанных") Тогда
		Направление = НаправлениеСортировкиКомпоновкиДанных.Возр;
	КонецЕсли;
	
	МассивПорядок.Добавить(Новый Структура("Поле, Направление", Поле, Направление));
КонецПроцедуры

// Возвращает группу отбора для запроса
//
// Параметры:
//	ТипГруппыИЛИ - Булево, Строка - по умолчанию группа И
//		Истина, "ИЛИ" - группа ИЛИ
//		Ложь, "И" - группа И
//
// Возвращаемое значение:
//   Структура 
//		type		- Строка - cqlFilterGroup
//		ТипГруппы	- ТипГруппыЭлементовОтбораКомпоновкиДанных - И, ИЛИ
//		Элементы	- Массив
// 
Функция cql_filterGroup(знач ТипГруппыИЛИ = Ложь) Экспорт 
	ТипГруппы = ?(ТипГруппыИЛИ = Истина ИЛИ ВРег(ТипГруппыИЛИ) = "ИЛИ",
		ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИли,
		ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИ);
	
	Структура = Новый Структура;
	Структура.Вставить("type"		, "cqlFilterGroup");
	Структура.Вставить("ТипГруппы"	, ТипГруппы);
	Структура.Вставить("Элементы"	, Новый Массив);
	
	Возврат Структура;
КонецФункции

// Возвращает структуру элемента поиска
// Особенности работы:
//	- confluence поддерживает поиск по одному или нескольким произвольным символам в строке:
//		* поиск по одному свободному символу - «?» (например: "?рест" - "крест", "трест" и т.д.)
//		* поиск по нескольким свободным символам - «*» (например: "лог*" - "логово", "логарифм" и т.д.)
//	- confluence поддерживает нечеткий поиск. Для нечеткого поиска используйте тильду, символ (~) в конце одного слова
//	- вид сравнения "Содержит" и "Не содержит" может быть использован только для полей "Текст", "Заголовок"
//		в противном случае будет вызвано исключение.
//	- вид сравнения "Не содержит" используется для поиска содержимого, в котором значение указанного поля не является
//		«нечетким» соответствием указанного значения
//
//	Примеры передачи использования условия "Содержит"
//		* Найти весь контент, где заголовок содержит слово "Победа": Поле = "Заголовок", Значение = "победа"
//		* Найти весь контент, где заголовок содержит свободные символы со словом "побед": Поле = "Заголовок", Значение = "побед*"
//		* Найти весь контент, где где текст содержит слово "продвинутый" и слово "поиск": Поле = "Текст", Значение = "продвинутый поиск"
//
// Параметры:
//	ПолеПоиска			- ПеречислениеСсылка.confluence_ПоляCQL
//	УсловиеСравнения	- ВидСравненияКомпоновкиДанных
//		Больше/Меньше(ИлиРавно), (Не)ВСписке, (Не)НачинаетсяС, (Не)Равно, (Не)Содержит
//	Значение			- Произвольный, Массив
//
// Возвращаемое значение:
//   Структура
//		type		- Строка - cqlFilterItem
//		Поле		- ПеречислениеСсылка.confluence_ПоляCQL
//		Условие		- ВидСравненияКомпоновкиДанных
//		Значение	- Произвольный, Массив
// 
Функция cql_filterItem(знач ПолеПоиска, знач Условие, знач Значение) Экспорт
	Если ВидСравненияНеПоддерживается(Условие) Тогда
		ВызватьИсключение СтрШаблон(НСтр("ru='Вид сравнения ""%1"" не поддерживается.'"), Строка(Условие));
	КонецЕсли;
	
	Структура = Новый Структура;
	Структура.Вставить("type"			, "cqlFilterItem");
	Структура.Вставить("Поле"			, ПолеПоиска);
	Структура.Вставить("ВидСравнения"	, Условие);
	Структура.Вставить("Значение"		, Значение);
	
	Возврат Структура;
КонецФункции

// Возвращает текст запроса cql или пустую строку (если произошла ошибка)
// ВНИМАНИЕ: если неверно передан отбор вызывается исключение
//
// Параметры:
//	МассивОтбор	- Массив - элемент массива см. cql_addFilterItem
//
// Возвращаемое значение:
//   Строка
// 
Функция get_cql_filter_text(знач МассивОтбор) Экспорт
	Если НЕ ТипЗнч(МассивОтбор) = Тип("Массив") Тогда 
		ВызватьИсключение СтрШаблон(
			НСтр("ru='При формировании текста CQL запроса передан неверный параметр (%1)'"),
			Строка(Тип(МассивОтбор)));
	КонецЕсли;
	
	СтрокаПоиска = "";
	Для Каждого ЭлементГруппаОтбора Из МассивОтбор Цикл
		СтрокаПоискаПоля = СформироватьСтрокуПоискаПоОтбору(ЭлементГруппаОтбора);
		Если ПустаяСтрока(СтрокаПоискаПоля) Тогда
			Продолжить;
		КонецЕсли;
		
		СтрокаПоиска = СтрокаПоиска + ?(ПустаяСтрока(СтрокаПоиска), "", " and ") + СтрокаПоискаПоля;
	КонецЦикла;
	
	Возврат СтрокаПоиска;
КонецФункции

// Возвращает текст упорядочивания результата запроса cql или пустую строку (если произошла ошибка)
// ВНИМАНИЕ: если неверно передан отбор вызывается исключение
//
// Параметры:
//	МассивПорядок	- Массив - элемент массива см. cql_addOrderItem
//
// Возвращаемое значение:
//   Строка
// 
Функция get_cql_order_text(знач МассивПорядок) Экспорт
	Если НЕ ТипЗнч(МассивПорядок) = Тип("Массив") Тогда 
		ВызватьИсключение СтрШаблон(
			НСтр("ru='При формировании текста упорядочивания CQL запроса передан неверный параметр (%1)'"),
			Строка(Тип(МассивПорядок)));
	КонецЕсли;
	
	СтрокаПорядка = "";
	Для Каждого ЭлементПорядка Из МассивПорядок Цикл
		Если НЕ ТипЗнч(ЭлементПорядка) = Тип("Структура") Тогда
			Продолжить;
		ИначеЕсли НЕ ЭлементПорядка.Свойство("Поле") Тогда
			Продолжить;
		ИначеЕсли НЕ ЭлементПорядка.Свойство("Направление") Тогда
			ЭлементПорядка.Вставить("Направление", НаправлениеСортировкиКомпоновкиДанных.Возр);
		КонецЕсли;
		
		ПараметрыПоля = confluence_ApiClientServerReuse.cql_fields_params(ЭлементПорядка.Поле); 
		Если НЕ ЗначениеЗаполнено(ПараметрыПоля.Поле) Тогда
			Продолжить;
		КонецЕсли;
			
		ПолеConfluence = ПараметрыПоля.Поле;
		НапрConfluence = ?(ЭлементПорядка.Направление = НаправлениеСортировкиКомпоновкиДанных.Убыв, "desc", "asc");
		
		СтрокаПорядка = СтрокаПорядка +
			?(ПустаяСтрока(СтрокаПорядка), "", ", ") +
			СтрШаблон("%1 %2", ПолеConfluence, НапрConfluence);
	КонецЦикла;
	СтрокаПорядка = ?(ПустаяСтрока(СтрокаПорядка), "", " order by ") + СтрокаПорядка;
	
	Возврат СтрокаПорядка;
КонецФункции

// Возвращает оператор cql по условию сравнения
//
// Параметры:
//	УсловиеСравнения - ВидСравненияКомпоновкиДанных
//
// Возвращаемое значение:
//   Строка
// 
Функция get_cql_operator_text(знач УсловиеСравнения) Экспорт
	Если УсловиеСравнения = ВидСравненияКомпоновкиДанных.Больше Тогда
		ТекстУсловия = ">%1";
	ИначеЕсли УсловиеСравнения = ВидСравненияКомпоновкиДанных.БольшеИлиРавно Тогда
		ТекстУсловия = ">=%1";
	ИначеЕсли УсловиеСравнения = ВидСравненияКомпоновкиДанных.ВСписке Тогда
		ТекстУсловия = " in (%1)";
	ИначеЕсли УсловиеСравнения = ВидСравненияКомпоновкиДанных.Меньше Тогда
		ТекстУсловия = "<%1";
	ИначеЕсли УсловиеСравнения = ВидСравненияКомпоновкиДанных.МеньшеИлиРавно Тогда
		ТекстУсловия = "<=%1";
	ИначеЕсли УсловиеСравнения = ВидСравненияКомпоновкиДанных.НачинаетсяС Тогда
		ТекстУсловия = "=%1*";
	ИначеЕсли УсловиеСравнения = ВидСравненияКомпоновкиДанных.НеВСписке Тогда
		ТекстУсловия = " not in (%1)";
	ИначеЕсли УсловиеСравнения = ВидСравненияКомпоновкиДанных.НеНачинаетсяС Тогда
		ТекстУсловия = "!=%1*";
	ИначеЕсли УсловиеСравнения = ВидСравненияКомпоновкиДанных.НеРавно Тогда
		ТекстУсловия = "!=%1";
	ИначеЕсли УсловиеСравнения = ВидСравненияКомпоновкиДанных.НеСодержит Тогда
		ТекстУсловия = "!~%1";
	ИначеЕсли УсловиеСравнения = ВидСравненияКомпоновкиДанных.Равно Тогда
		ТекстУсловия = "=%1";
	ИначеЕсли УсловиеСравнения = ВидСравненияКомпоновкиДанных.Содержит Тогда
		ТекстУсловия = "~%1";
	Иначе 
		ТекстУсловия = "";
	КонецЕсли;
	
	Возврат ТекстУсловия;
КонецФункции

#КонецОбласти

#Область ПрограммныйИнтерфейс_ПолучениеПараметров

// Возвращает структуру параметров для получения содержимого страницы
//
// Возвращаемое значение:
//   Структура
//		Контент			- Структура - см. content_expand_param
// 
Функция get_page_content_params() Экспорт
	ПараметрыКонтента = content_expand_param();
	ПараметрыКонтента.body_storage			= Истина;
	ПараметрыКонтента.children_attachments	= Истина;
	
	Структура = Новый Структура;
	Структура.Вставить("Контент", ПараметрыКонтента);
	
	Возврат Структура;
КонецФункции

// Возвращаем структуру параметров для получения списка меток по странице
//
// Возвращаемое значение:
//   Структура
//		Начало		- Число - начальный номер пространства
//		Количество	- Число - количество пространств на страницу запроса
//		Префикс		- Строка - фильтр для типа метки
//			Все - любая метка созданная пользователем
//			Мои - метки, созданные с префиксом "my:"
//			Скрытые - метки созданные с программно (см. set_page_label)
// 
Функция get_page_labels_params(знач Начало = 0, знач Количество = 0) Экспорт
	Структура = Новый Структура;
	Структура.Вставить("Начало"		, Начало);
	Структура.Вставить("Количество"	, Количество);
	Структура.Вставить("Префикс"	, ""); // global, my, team
	
	Возврат Структура;
КонецФункции

// Возвращает структуру параметров для получения списка разделов
//
// Возвращаемое значение:
//   Структура
//		Общие		- Булево - признак получения общих или персональных пространств 
//			Истина	- общие (global)
//			Ложь	- персональные (personal)
//			Неопределено - все
//		Действующие	- Булево
//			Истина - действующие (current)
//			Ложь - архивные (archived)
//			Неопределено - все
//		Метка		- Строка - поиск пространства по метке
//		Избранное	- Булево - получать избранные или все пространства
//			Истина	- только избранные
//			Ложь	- все пространства
//		Начало		- Число - начальный номер пространства
//		Количество	- Число - количество пространств на страницу запроса
// 
Функция get_all_spaces_params(знач Начало = 0, знач Количество = 0) Экспорт
	Структура = Новый Структура;
	Структура.Вставить("Общие"			, Неопределено);
	Структура.Вставить("Действующие"	, Неопределено);
	Структура.Вставить("Метка"			, "");
	Структура.Вставить("Избранное"		, Ложь);
	Структура.Вставить("Начало"			, Начало);
	Структура.Вставить("Количество"		, Количество);
	
	Возврат Структура; 
КонецФункции

// Возвращает структуру параметров для получения списка страниц по разделу
//
// Возвращаемое значение:
//   Структура
//		Статус		- Строка - статус для отбора, по умолчанию "Любой"
//			Удален, Текущий, Любой
//		Начало		- Число - начальный номер пространства
//		Количество	- Число - количество пространств на страницу запроса
//		Сортировка	- Строка - имя поля контента и направление сортировки (ВОЗР, УБЫВ)
//			Заголовок, ДатаСоздания, ДатаИзменения, Автор
//		Контент		- Структура - см. content_expand_param
// 
Функция get_all_pages_from_space_params(знач Начало = 0, знач Количество = 0) Экспорт
	ПараметрыКонтента = content_expand_param();
	
	Структура = Новый Структура;
	Структура.Вставить("Статус"			, "");
	Структура.Вставить("Начало"			, Начало);
	Структура.Вставить("Количество"		, Количество);
	Структура.Вставить("Сортировка"		, "Заголовок ВОЗР");
	Структура.Вставить("Контент"		, ПараметрыКонтента);
	
	Возврат Структура;
КонецФункции

// Возвращает структуру параметров для получения списка подчиненных страниц по типу
//
// Возвращаемое значение:
//   Структура
//		Начало		- Число - начальный номер пространства
//		Количество	- Число - количество пространств на страницу запроса
//		Контент		- Структура - см. content_expand_param
// 
Функция get_page_child_by_type_params(знач Начало = 0, знач Количество = 0) Экспорт
	ПараметрыКонтента = content_expand_param();
	
	Структура = Новый Структура;
	Структура.Вставить("Начало"		, Начало);
	Структура.Вставить("Количество"	, Количество);
	Структура.Вставить("Контент"	, ПараметрыКонтента);
	
	Возврат Структура;
КонецФункции

// Возвращает структуру параметров для получения содержимого страниц по разделу
//
// Возвращаемое значение:
//   Структура
//		Начало			- Число - начальный номер пространства
//		Количество		- Число - количество пространств на страницу запроса
//		ВсеСтраницы		- Булево - все страницы или только основную страницу раздела
//		Контент			- Структура - см. content_expand_param
// 
Функция get_space_content_params(знач Начало = 0, знач Количество = 0) Экспорт
	ПараметрыКонтента = content_expand_param();
	
	Структура = Новый Структура;
	Структура.Вставить("Начало"			, Начало);
	Структура.Вставить("Количество"		, Количество);
	Структура.Вставить("ВсеСтраницы"	, Истина);
	Структура.Вставить("Контент"		, ПараметрыКонтента);
	
	Возврат Структура;
КонецФункции

// Возвращает структуру параметров для получения списка вложений по странице
//
// Возвращаемое значение:
//   Структура
//		Начало		- Число - начальный номер пространства
//		Количество	- Число - количество пространств на страницу запроса
//		ИмяФайла	- Строка - имя поля файла для поиска
//		Контент		- Структура - см. content_expand_param
// 
Функция get_attachments_from_content_params(знач Начало = 0, знач Количество = 0) Экспорт
	ПараметрыКонтента = content_expand_param();
	
	Структура = Новый Структура;
	Структура.Вставить("Начало"			, Начало);
	Структура.Вставить("Количество"		, Количество);
	Структура.Вставить("ИмяФайла"		, "");
	Структура.Вставить("Контент"		, ПараметрыКонтента);
	
	Возврат Структура;
КонецФункции

// Возвращает параметры запроса к базе знаний
//
// Возвращаемое значение:
//   Структура
//		type			- Строка - cqlparams
//		Начало			- Число - начальный номер пространства
//		Количество		- Число - количество пространств на страницу запроса
//		Архив			- Булево - искать в архивных пространствах
//		Контент			- Структура - см. content_expand_param
// 
Функция cql_params(знач Начало = 0, знач Количество = 0, знач Архив = Ложь) Экспорт
	ПараметрыКонтента = content_expand_param();
	ПараметрыКонтента.body_storage = Истина;
	
	Структура = Новый Структура;
	Структура.Вставить("type"			, "cqlparams");
	Структура.Вставить("Начало"			, Начало);
	Структура.Вставить("Количество"		, Количество);
	Структура.Вставить("Архив"			, Архив);
	Структура.Вставить("Контент"		, ПараметрыКонтента);

	Возврат Структура;
КонецФункции

// Возвращает структуру параметров для получения данных контента страниц
//
// Возвращаемое значение:
//   Структура
//		body_storage			- Булево - включить содержимое страницы (body.storage)
//		body_styled_view		- Булево - включить представление страницы (body.styled_view)
//		children_attachments	- Булево - добавить информацию о вложениях (children.attachment)
//		metadata_labels			- Булево - добавить информацию о метках (metadata.labels)
// 
Функция content_expand_param() Экспорт
	Структура = Новый Структура;
	Структура.Вставить("body_storage"			, Ложь);
	Структура.Вставить("body_styled_view"		, Ложь);
	Структура.Вставить("children_attachments"	, Ложь);
	Структура.Вставить("metadata_labels"		, Ложь);
	
	Возврат Структура; 
КонецФункции

// Возвращает структуру параметров с минимальным набором данных
//
// Возвращаемое значение:
//   Структура
//		Начало		- Число - начальный номер пространства
//		Количество	- Число - количество пространств на страницу запроса
// 
Функция start_limit_params(знач Начало = 0, знач Количество = 0) Экспорт
	Структура = Новый Структура;
	Структура.Вставить("Начало"		, Начало);
	Структура.Вставить("Количество"	, Количество);
	
	Возврат Структура;
КонецФункции

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

Функция ПолучитьЗаголовки(знач Настройки, знач ТипКонтента = "application/json") Экспорт
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("X-Atlassian-Token", "no-check");
	
	Если ТипЗнч(ТипКонтента) = Тип("Строка") И НЕ ПустаяСтрока(ТипКонтента) Тогда
		Заголовки.Вставить("Content-Type", ТипКонтента);
	КонецЕсли;
	
	Если ТипЗнч(Настройки.ДанныеСессии) = Тип("Структура") 
		И Настройки.ДанныеСессии.Свойство("cookie") 
		И ЗначениеЗаполнено(Настройки.ДанныеСессии.cookie) Тогда
		Заголовки.Вставить("cookie", Настройки.ДанныеСессии.cookie);
	КонецЕсли;
	
	Возврат Заголовки;
КонецФункции

Функция ПолучитьСоединениеHTTP(знач Настройки) Экспорт
	ЗащищенноеСоединение = ?(Настройки.ЗащищенноеСоединение, Новый ЗащищенноеСоединениеOpenSSL, Неопределено);
	
	Если НЕ ПустаяСтрока(Настройки.Логин) Тогда
		Возврат Новый HTTPСоединение(Настройки.Сервер,, Настройки.Логин, Настройки.ТокенID,,, ЗащищенноеСоединение);
	Иначе 
		Возврат Новый HTTPСоединение(Настройки.Сервер,,,,,, ЗащищенноеСоединение);
	КонецЕсли;
КонецФункции

Функция СоответствиеИзОтвета(знач ОтветHTTP) Экспорт
	ТелоЗапроса = ОтветHTTP.ПолучитьТелоКакСтроку(КодировкаТекста.UTF8);
	
	#Если ВебКлиент Тогда
		Результат = confluence_ServerCall.ЗначениеИзСтрокиJSON(ТелоЗапроса);
	#Иначе
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(ТелоЗапроса);
		Результат = ПрочитатьJSON(ЧтениеJSON, Истина);
		ЧтениеJSON = Неопределено;
	#КонецЕсли
	
	Возврат Результат;
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции_ТекстCQL

Функция СформироватьСтрокуПоискаПоОтбору(знач ЭлементПоиска)
	ТекстПоиска = "";
	Если НЕ ТипЗнч(ЭлементПоиска) = Тип("Структура") Тогда
		Возврат ТекстПоиска;
	КонецЕсли;
	
	ТипНастройки = СвойствоСтруктуры(ЭлементПоиска, "type", "");
	Если НЕ ЗначениеЗаполнено(ТипНастройки) Тогда
		Возврат ТекстПоиска;
	КонецЕсли;
	
	ТипНастройки = НРег(ТипНастройки);
	
	Если ТипНастройки = "cqlfiltergroup" Тогда
		ТипГруппы		= СвойствоСтруктуры(ЭлементПоиска, "ТипГруппы", "");
		ЭлементыГруппы	= СвойствоСтруктуры(ЭлементПоиска, "Элементы", Новый Массив);
		
		Для Каждого ВложеннаяНастройка Из ЭлементыГруппы Цикл
			СтрокаПоиска = СформироватьСтрокуПоискаПоОтбору(ВложеннаяНастройка);
			Если ПустаяСтрока(СтрокаПоиска) Тогда
				Продолжить;
			КонецЕсли;
			
			СтрСоединение = ?(ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИли, " or ", " and ");
			
			ТекстПоиска = ТекстПоиска + ?(ПустаяСтрока(ТекстПоиска), "", СтрСоединение) + СтрокаПоиска;
		КонецЦикла;
	ИначеЕсли ТипНастройки = "cqlfilteritem" Тогда
		ПолеСравнения		= СвойствоСтруктуры(ЭлементПоиска, "Поле", Неопределено);
		УсловиеСравнения	= СвойствоСтруктуры(ЭлементПоиска, "ВидСравнения", Неопределено);
		ЗначениеСравнения	= СвойствоСтруктуры(ЭлементПоиска, "Значение", "");
		ПараметрыПоля		= confluence_ApiClientServerReuse.cql_fields_params(ПолеСравнения); 
		
		Если НЕ ТипЗнч(УсловиеСравнения) = Тип("ВидСравненияКомпоновкиДанных") Тогда
			Возврат ТекстПоиска;
		ИначеЕсли ВидСравненияНеПоддерживается(УсловиеСравнения) Тогда
			Возврат ТекстПоиска;
		ИначеЕсли ПустаяСтрока(ПараметрыПоля.Поле) Тогда
			Возврат ТекстПоиска;
		КонецЕсли;
		
		
		Если ПараметрыПоля.Условия.Количество() > 0 И ПараметрыПоля.Условия.Найти(УсловиеСравнения) = Неопределено Тогда
			ВызватьИсключение СтрШаблон(НСтр("ru='Вид сравнения ""%1"" не может быть использован с полем ""%2""'"),
				Строка(УсловиеСравнения),
				ПолеСравнения);
		КонецЕсли;
			
		ПолеConfluence		= ПараметрыПоля.Поле;
		ЗначениеConfluence	= ЗначениеВСтрокуConfluence(ЗначениеСравнения, ПараметрыПоля.Тип);
		ОператорConfluence	= get_cql_operator_text(УсловиеСравнения);
		
		Если ПустаяСтрока(ОператорConfluence) Тогда
			Возврат ТекстПоиска;
		КонецЕсли;
		
		ТекстПоиска = ПолеConfluence + СтрШаблон(ОператорConfluence, ЗначениеConfluence);
	КонецЕсли;
	
	Возврат "(" + ТекстПоиска + ")";
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции_ПараметрыЗапроса

Функция ПараметрыЗапроса_get_page_content(знач ПараметрыЗапроса)
	ПараметрыПоУмолчанию = get_page_content_params();
	ПроверитьПараметры(ПараметрыЗапроса, ПараметрыПоУмолчанию);
	
	СтрокаПараметры = "";
	СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "expand", ПараметрыЗапроса_content_expand_param(ПараметрыЗапроса.Контент));
	
	Возврат СтрокаПараметры;
КонецФункции

Функция ПараметрыЗапроса_get_all_spaces(знач ПараметрыЗапроса)
	ПараметрыПоУмолчанию = get_all_spaces_params();
	ПроверитьПараметры(ПараметрыЗапроса, ПараметрыПоУмолчанию);
	
	СтрокаПараметры = "";
	
	Если ПараметрыЗапроса.Общие = Истина Тогда
		СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "type", "global");
	ИначеЕсли ПараметрыЗапроса.Общие = Ложь Тогда
		СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "type", "personal");
	КонецЕсли;
	
	Если ПараметрыЗапроса.Действующие = Истина Тогда
		СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "status", "current");
	ИначеЕсли ПараметрыЗапроса.Действующие = Ложь Тогда
		СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "status", "archived");
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(ПараметрыЗапроса.Метка) Тогда
		СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "label", ПараметрыЗапроса.Метка);
	КонецЕсли;
	
	Если ПараметрыЗапроса.Избранное = Истина Тогда
		СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "favourite", "true");
	КонецЕсли;
	
	Если ПараметрыЗапроса.Начало > 0 Тогда
		СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "start", ЗначениеВСтрокуConfluence(ПараметрыЗапроса.Начало));
	КонецЕсли;
	
	Если ПараметрыЗапроса.Количество > 0 Тогда
		СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "limit", ЗначениеВСтрокуConfluence(ПараметрыЗапроса.Количество));
	КонецЕсли;
	
	Возврат СтрокаПараметры;
КонецФункции

Функция ПараметрыЗапроса_get_all_pages_from_space(знач ПараметрыЗапроса)
	ПараметрыПоУмолчанию = get_all_pages_from_space_params();
	ПроверитьПараметры(ПараметрыЗапроса, ПараметрыПоУмолчанию);
	
	СтрокаПараметры = "";
	СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "expand", ПараметрыЗапроса_content_expand_param(ПараметрыЗапроса.Контент));
	
	Если НЕ ПустаяСтрока(ПараметрыЗапроса.Статус) Тогда
		СтатусConfluence = СтатусВСтрокуConfluence(ПараметрыЗапроса.Статус);
		
		Если НЕ ПустаяСтрока(СтатусConfluence) Тогда
			СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "status", СтатусConfluence);
		КонецЕсли;
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(ПараметрыЗапроса.Сортировка) Тогда
		МассивПодстрок = СтрРазделить(ПараметрыЗапроса.Сортировка, " ");
		ПолеСортировки = ?(МассивПодстрок.Количество() > 0, СокрЛП(МассивПодстрок[0]), "");
		НапрСортировки = ?(МассивПодстрок.Количество() > 1, СокрЛП(МассивПодстрок[1]), "asc");
		
		Если НЕ ПустаяСтрока(ПолеСортировки) Тогда
			ПолеConfluence = ПолеСортировкиКонтентаВСтрокуConfluence(ПолеСортировки);
			НапрConfluence = ?(СокрЛП(НРег(НапрСортировки)) = "убыв", " desc", " asc");
			
			Если НЕ ПустаяСтрока(ПолеConfluence) Тогда
				СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "orderBy", ПолеConfluence + НапрСортировки);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Если ПараметрыЗапроса.Начало > 0 Тогда
		СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "start", ЗначениеВСтрокуConfluence(ПараметрыЗапроса.Начало));
	КонецЕсли;
	
	Если ПараметрыЗапроса.Количество > 0 Тогда
		СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "limit", ЗначениеВСтрокуConfluence(ПараметрыЗапроса.Количество));
	КонецЕсли;
	
	Возврат СтрокаПараметры;
КонецФункции

Функция ПараметрыЗапроса_get_page_child_by_type(знач ПараметрыЗапроса)
	ПараметрыПоУмолчанию = get_page_child_by_type_params();
	ПроверитьПараметры(ПараметрыЗапроса, ПараметрыПоУмолчанию);
	
	СтрокаПараметры = "";
	СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "expand", ПараметрыЗапроса_content_expand_param(ПараметрыЗапроса.Контент));
	
	Если ПараметрыЗапроса.Начало > 0 Тогда
		СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "start", ЗначениеВСтрокуConfluence(ПараметрыЗапроса.Начало));
	КонецЕсли;
	
	Если ПараметрыЗапроса.Количество > 0 Тогда
		СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "limit", ЗначениеВСтрокуConfluence(ПараметрыЗапроса.Количество));
	КонецЕсли;
	
	Возврат СтрокаПараметры;
КонецФункции

Функция ПараметрыЗапроса_get_space_content(знач ПараметрыЗапроса)
	ПараметрыПоУмолчанию = get_space_content_params();
	ПроверитьПараметры(ПараметрыЗапроса, ПараметрыПоУмолчанию);
	
	СтрокаПараметры = "";
	СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "expand", ПараметрыЗапроса_content_expand_param(ПараметрыЗапроса.Контент));
	
	Если ПараметрыЗапроса.ВсеСтраницы = Ложь Тогда
		СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "depth", "root");
	КонецЕсли;
	
	Если ПараметрыЗапроса.Начало > 0 Тогда
		СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "start", ЗначениеВСтрокуConfluence(ПараметрыЗапроса.Начало));
	КонецЕсли;
	
	Если ПараметрыЗапроса.Количество > 0 Тогда
		СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "limit", ЗначениеВСтрокуConfluence(ПараметрыЗапроса.Количество));
	КонецЕсли;
	
	Возврат СтрокаПараметры;
КонецФункции

Функция ПараметрыЗапроса_get_attachments_from_content(знач ПараметрыЗапроса)
	ПараметрыПоУмолчанию = get_attachments_from_content_params();
	ПроверитьПараметры(ПараметрыЗапроса, ПараметрыПоУмолчанию);
	
	СтрокаПараметры = "";
	СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "expand", ПараметрыЗапроса_content_expand_param(ПараметрыЗапроса.Контент));
	
	Если ПараметрыЗапроса.Начало > 0 Тогда
		СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "start", ЗначениеВСтрокуConfluence(ПараметрыЗапроса.Начало));
	КонецЕсли;
	
	Если ПараметрыЗапроса.Количество > 0 Тогда
		СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "limit", ЗначениеВСтрокуConfluence(ПараметрыЗапроса.Количество));
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(ПараметрыЗапроса.ИмяФайла) Тогда
		СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "filename", ЗначениеВСтрокуConfluence(ПараметрыЗапроса.ИмяФайла));
	КонецЕсли;
	
	Возврат СтрокаПараметры;
КонецФункции

Функция ПараметрыЗапроса_cql(знач ПараметрыЗапроса)
	ПараметрыПоУмолчанию = cql_params();
	ПроверитьПараметры(ПараметрыЗапроса, ПараметрыПоУмолчанию);
	
	СтрокаПараметры = "";
	
	Если ПараметрыЗапроса.Начало > 0 Тогда
		СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "start", ЗначениеВСтрокуConfluence(ПараметрыЗапроса.Начало));
	КонецЕсли;
	
	Если ПараметрыЗапроса.Количество > 0 Тогда
		СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "limit", ЗначениеВСтрокуConfluence(ПараметрыЗапроса.Количество));
	КонецЕсли;
	
	Если ПараметрыЗапроса.Архив = Истина Тогда
		СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "includeArchivedSpaces", "true");
	КонецЕсли;
	
	Возврат СтрокаПараметры;
КонецФункции

Функция ПараметрыЗапроса_start_limit(знач ПараметрыЗапроса)
	СтрокаПараметры = "";
	
	Если ПараметрыЗапроса.Начало > 0 Тогда
		СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "start", ЗначениеВСтрокуConfluence(ПараметрыЗапроса.Начало));
	КонецЕсли;
	
	Если ПараметрыЗапроса.Количество > 0 Тогда
		СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "limit", ЗначениеВСтрокуConfluence(ПараметрыЗапроса.Количество));
	КонецЕсли;
	
	Возврат СтрокаПараметры;
КонецФункции

Функция ПараметрыЗапроса_content_expand_param(знач ПараметрыЗапроса)
	ПараметрыПоУмолчанию = content_expand_param();
	ПроверитьПараметры(ПараметрыЗапроса, ПараметрыПоУмолчанию);
	
	СтрПараметры = "childTypes.page,childTypes.attachment,description.view,version,ancestors,space";
	
	Если ПараметрыЗапроса.body_storage = Истина Тогда
		СтрПараметры = СтрПараметры + ",body.storage";
	КонецЕсли;
	
	Если ПараметрыЗапроса.body_styled_view = Истина Тогда
		СтрПараметры = СтрПараметры + ",body.styled_view";
	КонецЕсли;
	
	Если ПараметрыЗапроса.children_attachments = Истина Тогда
		СтрПараметры = СтрПараметры + ",children.attachment";
	КонецЕсли;
	
	Если ПараметрыЗапроса.metadata_labels = Истина Тогда
		СтрПараметры = СтрПараметры + ",metadata.labels";
	КонецЕсли;
	
	Возврат СтрПараметры;
КонецФункции

Функция ПараметрыЗапроса_get_page_labels(знач ПараметрыЗапроса)
	ПараметрыПоУмолчанию = get_page_labels_params();
	ПроверитьПараметры(ПараметрыЗапроса, ПараметрыПоУмолчанию);
	
	СтрокаПараметры = "";
	
	Если ПараметрыЗапроса.Начало > 0 Тогда
		СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "start", ЗначениеВСтрокуConfluence(ПараметрыЗапроса.Начало));
	КонецЕсли;
	
	Если ПараметрыЗапроса.Количество > 0 Тогда
		СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "limit", ЗначениеВСтрокуConfluence(ПараметрыЗапроса.Количество));
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(ПараметрыЗапроса.Префикс) Тогда
		ПрефиксConfluence = ПрефиксМеткиВСтрокуConfluence(ПараметрыЗапроса.Префикс);
		
		Если НЕ ПустаяСтрока(ПрефиксConfluence) Тогда
			СтрокаПараметры = ДополнитьПараметрыЗапроса(СтрокаПараметры, "prefix", ПрефиксConfluence);
		КонецЕсли;
	КонецЕсли;
	
	Возврат СтрокаПараметры;
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции_ОбщегоНазначения

Процедура ПроверитьПараметры(СтруктураПараметры, знач ПараметрыПоУмолчанию)
	Если НЕ ТипЗнч(СтруктураПараметры) = Тип("Структура") Тогда
		СтруктураПараметры = Новый Структура;
	КонецЕсли;
	
	Для Каждого КлючИЗначение Из ПараметрыПоУмолчанию Цикл
		ЗначениеПараметра = СвойствоСтруктуры(СтруктураПараметры, КлючИЗначение.Ключ, КлючИЗначение.Значение);
		СтруктураПараметры.Вставить(КлючИЗначение.Ключ, ЗначениеПараметра);
	КонецЦикла;
КонецПроцедуры

Функция ВидСравненияНеПоддерживается(знач УсловиеСравнения)
	Возврат УсловиеСравнения = ВидСравненияКомпоновкиДанных.ВИерархии
		ИЛИ УсловиеСравнения = ВидСравненияКомпоновкиДанных.НеВИерархии
		ИЛИ УсловиеСравнения = ВидСравненияКомпоновкиДанных.ВСпискеПоИерархии
		ИЛИ УсловиеСравнения = ВидСравненияКомпоновкиДанных.НеВСпискеПоИерархии
		ИЛИ УсловиеСравнения = ВидСравненияКомпоновкиДанных.Заполнено
		ИЛИ УсловиеСравнения = ВидСравненияКомпоновкиДанных.НеЗаполнено
		ИЛИ УсловиеСравнения = ВидСравненияКомпоновкиДанных.Подобно
		ИЛИ УсловиеСравнения = ВидСравненияКомпоновкиДанных.НеПодобно;
КонецФункции

Функция ПолучитьСтрокуJSON(знач ОбъектДанных)
	
	#Если ВебКлиент Тогда
		СтрокаJSON = confluence_ServerCall.ЗначениеВСтрокуJSON(ОбъектДанных);
	#Иначе
		ЗаписьJSON = Новый ЗаписьJSON;
		ЗаписьJSON.УстановитьСтроку();
		ЗаписьJSON.ПроверятьСтруктуру = Ложь;
		ЗаписатьJSON(ЗаписьJSON, ОбъектДанных);
		СтрокаJSON = ЗаписьJSON.Закрыть();
		ЗаписьJSON = Неопределено;
	#КонецЕсли
	
	Возврат СтрокаJSON;
	
КонецФункции

Функция ДополнитьПараметрыЗапроса(знач ПараметрыЗапроса, знач Поле, знач Значение)
	Возврат СтрШаблон("%1%2%3=%4",
		ПараметрыЗапроса,
		?(ПустаяСтрока(ПараметрыЗапроса), "", "&"),
		Поле,
		Значение);
КонецФункции

Функция ЗначениеПараметраИзСтроки(знач ДанныеСтроки, знач Ключ)
	НРегДанные = НРег(ДанныеСтроки);
	Позиция = СтрНайти(НРегДанные, НРег(Ключ) + "=");
	Если Позиция = 0 Тогда
		Возврат "";
	КонецЕсли;
	
	Начало		= Позиция + СтрДлина(Ключ) + 2;
	Окончание	= СтрНайти(ДанныеСтроки, ";",, Начало);
	Если Окончание = 0 Тогда
		Возврат Сред(ДанныеСтроки, Начало);
	Иначе 
		Возврат Сред(ДанныеСтроки, Начало, Окончание - Начало);
	КонецЕсли;
КонецФункции

Функция СвойствоСтруктуры(Структура, Ключ, ПоУмолчанию = Неопределено)
	Возврат confluence_CommonClientServer.СвойствоСтруктуры(Структура, Ключ, ПоУмолчанию);
КонецФункции

Функция СвойствоСоответствия(знач Соответствие, знач ПутьКСвойству, знач ПоУмолчанию = Неопределено, знач КакЧисло = Ложь)
	Возврат confluence_CommonClientServer.СвойствоСоответствия(Соответствие, ПутьКСвойству, ПоУмолчанию, КакЧисло);
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции_КонвертацияДанных

Функция ЗначениеВСтрокуConfluence(знач ЗначениеСравнения, знач ДопустимыеТипы = Неопределено)
	КонтрольТипов = (ТипЗнч(ДопустимыеТипы) = Тип("ОписаниеТипов"));
	
	ТипЗначенияСравнения = ТипЗнч(ЗначениеСравнения);
	
	Если ТипЗначенияСравнения = Тип("Массив") ИЛИ ТипЗначенияСравнения = Тип("ФиксированныйМассив") Тогда  
		СтрРезультат = "";
		Для Каждого ЗначениеМассива Из ЗначениеСравнения Цикл
			СтрРезультат = СтрРезультат + ?(ПустаяСтрока(СтрРезультат), "", ", ") + ЗначениеВСтрокуConfluence(ЗначениеМассива, ДопустимыеТипы);
		КонецЦикла;
		
		Возврат СтрРезультат;
	ИначеЕсли ТипЗначенияСравнения = Тип("СписокЗначений") Тогда  
		СтрРезультат = "";
		Для Каждого ЭлементСписка Из ЗначениеСравнения Цикл
			СтрРезультат = СтрРезультат + ?(ПустаяСтрока(СтрРезультат), "", ", ") + ЗначениеВСтрокуConfluence(ЭлементСписка.Значение, ДопустимыеТипы);
		КонецЦикла;
		
		Возврат СтрРезультат;
	КонецЕсли;
	
	Если КонтрольТипов И НЕ ДопустимыеТипы.СодержитТип(ТипЗначенияСравнения) Тогда
		Возврат "";
	КонецЕсли;
	
	Если ТипЗначенияСравнения = Тип("Строка") Тогда
		ЗначениеConfluence = """" + ЗначениеСравнения + """";
	ИначеЕсли ТипЗначенияСравнения = Тип("Число") Тогда  
		ЗначениеConfluence = Формат(ЗначениеСравнения, "ЧН=0; ЧГ=");
	ИначеЕсли ТипЗначенияСравнения = Тип("Дата") Тогда  
		ЗначениеConfluence = """" + Формат(ЗначениеСравнения, "ДФ='yyyy/MM/dd HH:mm'") + """";
	ИначеЕсли ТипЗначенияСравнения = Тип("Булево") Тогда
		ЗначениеConfluence = Формат(ЗначениеСравнения, "БЛ=false; БИ=true");
	ИначеЕсли ТипЗначенияСравнения = Тип("ПеречислениеСсылка.confluence_ТипыДанных") Тогда
		ЗначениеConfluence = ТипДанныхВСтрокуConfluence(ЗначениеСравнения);
	Иначе
		Попытка
			ЗначениеConfluence = Строка(ЗначениеСравнения);
		Исключение
			ВызватьИсключение СтрШаблон(НСтр("ru='Тип данных ""%1"" не поддерживается.'"), Строка(ТипЗначенияСравнения));
		КонецПопытки;
	КонецЕсли;
	
	Возврат ЗначениеConfluence;
КонецФункции

Функция СтатусВСтрокуConfluence(знач Статус)
	НРегСтатус = НРег(Статус);
	
	СтруктураСтатусов = confluence_ApiClientServerReuse.content_status(Истина); 
	Если СтруктураСтатусов.Свойство(НРегСтатус) Тогда
		Возврат СтруктураСтатусов[НРегСтатус];
	Иначе 
		Возврат "";
	КонецЕсли;
КонецФункции

Функция ПрефиксМеткиВСтрокуConfluence(знач Префикс)
	НРегПрефикс = НРег(Префикс);
	
	СтруктураПрефиксов = confluence_ApiClientServerReuse.label_prefix(Истина); 
	Если СтруктураПрефиксов.Свойство(НРегПрефикс) Тогда
		Возврат СтруктураПрефиксов[НРегПрефикс];
	Иначе 
		Возврат "";
	КонецЕсли;
КонецФункции

Функция ТипДанныхВСтрокуConfluence(знач ТипДанных)
	Если ТипДанных = ПредопределенноеЗначение("Перечисление.confluence_ТипыДанных.Статья") Тогда
		Возврат "page";
	ИначеЕсли ТипДанных = ПредопределенноеЗначение("Перечисление.confluence_ТипыДанных.ЗаписьБлога") Тогда
		Возврат "blogpost";
	ИначеЕсли ТипДанных = ПредопределенноеЗначение("Перечисление.confluence_ТипыДанных.Комментарий") Тогда
		Возврат "comment";
	ИначеЕсли ТипДанных = ПредопределенноеЗначение("Перечисление.confluence_ТипыДанных.Вложение") Тогда
		Возврат "attachment";
	ИначеЕсли ТипДанных = ПредопределенноеЗначение("Перечисление.confluence_ТипыДанных.Пространство") Тогда
		Возврат "space";
	Иначе
		Возврат "";
	КонецЕсли;
КонецФункции

Функция ПолеСортировкиКонтентаВСтрокуConfluence(знач ПолеКонтента)
	НРегПолеКонтента = СокрЛП(НРег(ПолеКонтента));
	Если НРегПолеКонтента = "заголовок" Тогда
		Возврат "title";
	ИначеЕсли НРегПолеКонтента = "датасоздания" Тогда
		Возврат "contentHistory.createdDate";
	ИначеЕсли НРегПолеКонтента = "датаизменения" Тогда
		Возврат "contentHistory.lastUpdated";
	ИначеЕсли НРегПолеКонтента = "автор" Тогда
		Возврат "contentHistory.createdBy.publicName";
	КонецЕсли;
	
	Возврат "";
КонецФункции

#КонецОбласти
